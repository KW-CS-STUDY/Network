# NetWork
1. [인터넷이란?](#인터넷이란)
2. [프로토콜이란?](#프로토콜이란)
3. [네트워크 가장자리(network edge)](#네트워크-가장자리network-edge)
4. [네트워크 코어(중심부/network core)](#네트워크-코어중심부network-core)
5. [프로토콜 계층과 서비스 모델](#프로토콜-계층과-서비스-모델)
---
6. [애플리케이션 아키텍처](#애플리케이션-아키텍처)
7. [웹과 HTTP](#웹과-http)
8. [인터넷 전자메일](#인터넷-전자메일)
9. [DNS(Domain Name System) 인터넷 디렉터리 서비스](#dnsdomain-name-system-인터넷-디렉터리-서비스)
10. [P2P 애플리케이션](#p2p-애플리케이션)
---
# 일정
1. 2주차
   1. 3-1(애플리케이션 계층) 네트워크, 애플리케이션, 웹 과 http 원리
   2. 3-2(애플리케이션 계층) HTTP
   3. 4-1(애플리케이션 계층) FTP, 전자우편(Electronic mail) SMTP
2. 3주차
   1. 5(애플리케이션 계층) 전자우편(Electronic mail) POP3,IMAP,DNS
   2. 6(애플리케이션 계층) P2P 애플리케이션
   3. 6-2(애플리케이션 계층) UDP와 TCP를 통한 소켓프로그래밍 및 트랜스포트 계층 서비스, Multiplexing Demultiplexing
3. 4주차
   1. 7(트랜스포트 계층) 비연결형 트랜스포트:UDP, 신뢰성있는 데이터전송의 원리, 연결지향형 트랜스포트:TCP
   2. 8(트랜스포트 계층) 연결지향형 트랜스포트:TCP
   3. 9(트랜스포트 계층) 혼잡제어의 원리
4. 5주차
   1. 9-2(네트워크 계층) 가상회선과 데이터그램, 네트워크
   2. 10(네트워크 계층) 라우터 내부
   3. 10-2(네트워크 계층) IP:인터넷 프로토콜
5. 6주차
   1. 11(네트워크 계층) 라우팅 알고리즘
   2. 12(네트워크 계층) 인터넷 속 라우팅, 
   3. 13 브로드케스트 멀티케스트 라우팅
6. 7주차
   1. 14(링크 계층)
   2. 15 무선과 모바일 네트워크

---




# 1주차
# 인터넷이란? 
## 인터넷의 구성요소
1.  네트워크의 가장자리(network edge)

    * 컴퓨터 or 서버 -> ("host" or "end system")이라 부름

2.  네트워크 코어(network core)

    * 라우터(스위치) : 사용자에게 전달되어야할 메시지를 목적지에 찾아갈 수 있게 하는 역할


3. 링크 : 물리적인 실제 회선  

<br/>

* 인터넷(Internet) : 네트워크들 속에서의 네트워크 -> 즉 네트워크들이 모인 곳에서의 네트워크를 말함

### 프로토콜(Protocols) : 인터넷에서 메시지를 보내고 받는 규칙

  * 인터넷 통신을 하기 위해서는 프로토콜 표준화가 매우 중요함

  * ex) TCP, IP, HTTP, Skype, 802.11 ...

### 인터넷 표준화(Internet standards)

  * IETF(Internet Engineering Task Force) : 인터넷 프로토콜의 표준화 기관

  * RFC(Request for comments) : IETF에서 RFC라는 표준안을 발표함

<br/>

# 프로토콜이란?
보내고 받는 메시지의 형식(format), 순서(Order), 액션(action)을 정의(약속)한다. 

<br/>

# 네트워크 가장자리(network edge)
* 종단 시스템(end system) : 인터넷에 연결되는 컴퓨터와 다른 장치들은 인터넷의 가장자리를 차지하고 있기 때문에 end system이라 한다.

	* ex) **데스크톱**(데스크톱 PC, 매킨토시, 리눅스 컴퓨터...), **서버**(웹과 전자메일 서버), **모바일 컴퓨터**(스마트폰, 태블릿, 랩톱)...

* 호스트(host) : 네트워크 애플리케이션을 호스팅하고 있는 end system을 지칭하는 말

	* 클라이언트 와 서버로 구분 

## 접속 네트워크(access network)
host 혹은 end system들을 네트워크에 연결시켜주는 놈

### access network를 구분짓는 요소

1. bandwidth(대역폭)
   
2. 다른 사람과 공유를 하는지 공유 유무

### access network 종류

1. DSL : Digital Subscriber Line, 전화선을 이용한 인터넷 서비스, 현재는 잘 쓰이지 않음

2. 케이블(cable) network : 케이블로 연결한 네트워크 서비스

3. home network : 집 내부에 구성하고 있는 네트워크
   1. 데스크톱을 home network 연결 -> home network을 케이블회사 or DSL(전화회사) 연결

4. 무선(Wireless) 네트워크
   1. 무선 랜(LAN) : 802.11b/g(WiFi)
   2. 광대역 무선 네트워크 : 셀룰러(3G, 4G, LTE)

<br/>

# 네트워크 코어(중심부/network core)
source에서 destination으로 사용자의 애플리케이션 메시지를 전달해 주는 것이 목표이다.  

### 전달해 주는 방식
1. 회선교환(packet switching)

2. 패킷교환(circuit switching )

## 회선교환(circuit switching)
<img width="431" alt="스크린샷 2022-08-05 오후 12 38 50" src="https://user-images.githubusercontent.com/87526189/183372743-f44c2142-350b-4979-ab7b-1778c9cafc70.png">  

주로 전화 네트워크에서 사용되는 방식으로 user가 call을 하면 call set up 과정을 거쳐서 둘 사이에 파이프로 연결된 것 처럼 연결할 수 있다.

### call set up에서 하는 일
1. source -> destination 전달되는 경로를 결정함(어떤 라우터 스위치를 경유할 것인지)
 
2. 그 경로상의 자원이 예약됨

경로상의 자원은 한정적이기 때문에 분할하여 여러사용자가 사용할 수 있도록 한다.

### 네트워크 자원을 분할하는 방법
1. FDM(frequency division multiplexing) : 주파수 분할 다중화

	* 주파수 대역폭을 기준으로 사용자별로 다른 대역을 할당해 준다

2. TDM(Time division multiplexing) : 시 분할 다중화 

	* 링크에 가용한 대역폭 전체를 사용자들이 사용할 수 있게 하되 시간을 기준으로 잘라서 시간을 할당함

## 패킷교환(packet switching)
circuit switching은  전화에서는 지속적인 연결이 필요하므로 적합했지만 컴퓨터 간의 통신에서는 데이터 네트워크인 인터넷에서는 Request가 올 때는 대량의 데이터가 발생하지만 한 동안은 데이터가 발생하지 않는다.  

따라서 circuit switching은 인터넷과 같은 데이터 네트워크에서는 비효율적이다. 그래서 등장하게 된 것이 packet switcing이다.

### 패킷교환(packet switcing)의 주요 개념
1. 예약이 없다. -> No call set up / No resource reservation
	* 필요가 발생하면 그때그때 마다 resource를 사용할 수 있게 한다.

2. 데이터를 패킷으로 잘라야한다.

3. 패킷의 목적지 주소가 명시되어 있어야한다.(예약어가 없기 때문)
	* 라우터는 패킷을 받으면 패킷의 목적지 주소를 보고 다음 라우터의 위치를 결정한다.  

4. 저장 후 전달 전송(store-and-forward)
	* 각 라우터는 패킷 하나를 다 받아야지만 목적지 정보를 파싱하고 다음 위치로 보낼 수 있기 때문에 패킷 전체가 도달 할 때 까지는 일단 받는 작업만 한다.

### 큐잉지연(queueing delay) 과 패킷 손실(loss)
패킷 스위치는 출력 버퍼를 가지고 있고, 링크로 송신하려는 패킷을 저장하고 있다.  

패킷이 한 링크로 전송하려고 했는데 그 링크가 다른 패킷을 전송하고 있다면, 도착한 패킷은 출력 버퍼에서 대기한다.  

이때 패킷은 출력버퍼에서 큐잉지연(queueing delay)을 겪게된다.  

버퍼의 공간은 유한하기 때문에 패킷으 로 꽉 차있을 수 있으며 이 경우 다른 패킷이 도착하면 패킷손실(packet loss)가 발생한다.  

<br/>

# 프로토콜 계층과 서비스 모델
인터넷은 매우 복잡한 시스템이다.  

인터넷은 다양한 애플리케이션과 프로토콜, 여러가지 종단 시스템(End System)과 종단 시스템 간의 연결, 라우터, 다양한 링크 수준의 매체가 있음을 보았다. 

이러한 복잡한 네트워크 구조를 어떻게 조직화 할 수 있을까?  

## 계층구조(layering)
프로토콜은 매우 방대하고 복잡하기 때문에 계층구조로 되어있다. 

### 계층구조의 장점
1. 복잡한 시스템의 조각들을 식별하고 그것들 관의 관계를 정의하는 것이 용이해진다.  

2. 업데이트와 유지보수가 쉬워진다.

    * 방대한 프로그램을 하나의 함수로 구현하면 유지보수하기 어려울 것이다. 하지만 기능별로 나눠서 함수로 구현하게 되면 유지보수하기 용이해질 것이다. 마찬가지로 방대한 프로토콜 시스템을 계층으로 나누면 유지보수와 업데이트하기 쉬워진다.

### 계층구조의 단점
1. 계층의 기능을 독립적으로 계층의 목적을 정의하고 목적에 맞춰서 기능을 구현하다보면 그 기능들 간에는 서로 겹쳐지는 부분이 발생할 수 있다.

2. 한 계층에서 최적으로 작동하기 위해서는 다른 계층에서 수집하고 있는 정보나 다른 계층에서만 알려지게되는 정보를 필요로 할 수 있다. 그럴때 엄격하게 계층을 구분해 놓으면 두 계층간에 커뮤니케이션이 있어야만 다른 계층에서 발생한 정보를 가져올 수 있기 때문에 오버헤드가 발생할 수 있다. 
 
     * -> 즉 어떤 계층의 기능을 구현하는 것이 최적이지 않을 수 있다.

### 인터넷의 5개 계층의 프로토콜 스택

![image](https://user-images.githubusercontent.com/87526189/183373019-709901a2-835a-4f8b-9bb6-d76a08aaa002.png)

1. 애플리케이션(application) : 네트워크 애플리케이션 프로그램을 지원하는 역할

    * 유저가 애플리케이션 프로그램에서 발생시킨 데이터를 어떻게 메시지로 만드느냐 하는 것이 애플리케이션 계층의 주된 역할

    * ex) web 애플리케이션 -> HTTP라는 프로토콜이 web 애플리케이션 프로그램을 지원하고 있다.

    * ex) email -> SMTP프로토콜

    * ex) 파일전송(file transfer) -> FTP

2. 트랜스포트(transport)

    * 애플리케이션 프로그램에서 만들어진 메시지를 목적지 프로그램으로 전달해주는 역할

    * process to process 전송을 수행하는 계층

    * TCP와 UDP라는 트랜스포트 프로토콜이 있음

3. 네트워크(network)

    * 트랜스포트 계층에서 process to process 전송을 수행하기 위해 host to host 전송을 네트워크 계층에게 부탁함

    * 라우팅(길찾기)을 통해 source host(SH)로 부터 destination host(DH)까지 배달해줌

4. 링크(link)

    * SH에서 DH까지 배달하기 위해서 hop by hop으로 네트워크 노드를 거쳐가야한다. 한 hop 전달하는 것을 링크에게 부탁함

5. 물리(physical)
   
    * 링크 계층에서 한 hop을 건너가기 위해 물리계층에게 transmission medium에다가 데이터를 실어 나르는 일을 부탁함

각 계층은 바로 아래 계층의 서비스를 이용하여 자신의 프로토콜 계층의 목표를 달성하게 된다.  

### **OSI 7계층의 모델**
위 프로토콜 스택이 유일한 프로토콜 스택이 아니다.  

1970년대 후반 ISO(International Organization for Standardization)은 컴퓨터 네트워크가 7계층으로 구성되어야 한다는 제안을 했는데 이를 OSI(Open System Interconnection)라고 부른다.

![image](https://user-images.githubusercontent.com/87526189/183402540-3b432c41-193a-4230-80ab-66c55f3d7ca2.png)

이들 계층 중 5개 계층의 기능은 비슷하게 이름 붙여진 인터넷 계층과 거의 비슷하 다. 따라서 OSI 참조 모델에 있는 2개의 추가 계층들(프레젠테이션 계층과 세션 계층) 만 살펴본다.

1. 프레젠테이션 계층 : 통신하는 애플리케이션들이 교환되는 데이터의 의미를 해석하도록 하는 서비스를 제공하는 것이다. 이들 서비스는 데이터 기술 뿐만 아니라 데이터 압축과 데이터 암호화를 포함한다.

2. 세션 계층 : 데이터 교환의 경계와 동기화를 제공한다. 이에는 체킹포인트와 회복 방법을 세우는 수단을 포함한다.

인터넷이 OSI참조 모델에서 찾을 수 있는 2개 계층이 없다는 사실은 두 가지 질문을 하게 만든다.  

1. 이들 계층이 제공하는 서비스는 중요하지 않은가?

2. 애플리케이션이 이 두 서비스중 하나를 요구하면 어떻게 되는가? 

<br/>

이에 대한 대답은 애플리케이션 개발자에게 달려있다.  

그 서비스 가 종요하다면 기 기능을 애플리케이션에 넣는 것은 애플리케이션 개발자에게 달려있다.
 
## 캡슐화(Encapsulation)
![스크린샷 2022-08-08 오후 8 04 58](https://user-images.githubusercontent.com/87526189/183404129-28e76109-c366-4940-a409-80322f1d575d.png)

### 세그먼트
애플리케이션 계층 메시지는 트랜스포트 계층으로 보내진다.  

트랜스포트 계층은 메시지에 수신 측 트랜스포트 계층에서 사용될 추가 정보(헤더 정보)를 더한다.  

애플리케이션 계층 메시지와 트랜스포트 계층 헤더정보는 모두 트랜스포트 계층 세그먼트를 구성한다.

트랜스포트 계층 세그먼트는 애플리케이션 계층 메시지를 캡슐화한다.

### 데이터그램
트랜스포트 계층은 세그먼트를 네트워크 계층으로 보내며 네트워크 계층은 출발지와 목적지 종단 시스템 주소와 동일한 헤더 정보를 추가하여 네트워크 계층 데이터그램을 만든다

### 프레임
데이터그램은 링크 계층으로 전달되고 링크 계층도 자신의 헤더 정보를 추가하고 링크 계층 프 레임을 만든다.

<br/>

---------------------------------------------------
# 2주차

# 애플리케이션 아키텍처
현대의 네트워크 애플리케이션과 네트워크 애플리케이션을 지원하는 애플리케이션 프로토콜은 2가지 중 하나의 아키텍처를 가진다.
1. 클라이언트-서버

2. P2P 아키텍처

## 클라이언트-서버 아키텍처
* 서버(server)
  * 항상 켜져있는 호스트를 서버라 함
  
  * 영구적으로 할당된 IP주소를 가지고 있는 호스트이다.

  * 클라이언트가 많을 때는 각각의 클라이언트를 응대하기 위해 데이터 센터형식으로 동일한 기능을 하는 서버가 군집되어 있는 형태로 존재

* 클라이언트(client)
  * 서버와 통신을 함

  * 인터넷에 간혈적으로 연결된다.

  * 동적인(dynamic) IP주소를 할당 받는다.
    * 인터넷에 연결될 때마다 변경이 가능한 주소를 말함

## P2P 아키텍처
* 항상 켜져있는 서버를 사용하지 않는다.

* 커뮤니케이션 하는 호스트를 peer라고 부름
  * peer는 다른 호스트로부터 요청하기도 하고 다른 peer에게 서비스를 제공해주기도 한다.
  
    * 자가 확장성(self-scalability)을 가진다.

* peer들은 간혈적으로 연결되고 IP가 변경되기 때문에 관리가 매우 복잡하다.

<br/>

# 프로세스 간 통신
서로 다른 호스트 간의 프로세스들 사이에서 메시지를 통해 통신을 한다.

## 통신하는 프로세스의 종류
1. 클라이언트 프로세스 : 통신을 시도하는 프로세스

2. 서버 프로세스 : 대기하고 있다가 클라이언트의 접근을 받아서 응답함

## 프로세스와 컴퓨터 네트워크 사이의 인터페이스

### 소켓(Socket)
![image](https://user-images.githubusercontent.com/87526189/184467905-4fe266e2-0672-4bc2-b9d2-0bbebdf5f1ea.png)  

트랜스포트 계층과 애플리케이션 계층간의 연결되는 문이 있어야 하는데 이것을 소켓이라 한다.

## 프로세스 주소 배정

* host의 IP정보만으로는 궁극적으로 메시지가 전달되어야할 애플리케이션 프로세스를 식별할 수가 없다.

* host를 식별하는 32bit IP와 더불어 **포트(port)** 번호를 사용한다.

  * 포트(port) : host안에서 실행되고 있는 프로세스를 식별해주는 번호

* 포트번호의 예

  * HTTP 서버 프로세스 : 80

  * mail 서버 프로세스 : 25
    * 이러한 포트번호를 well known port number라함

* 결론 : host는 IP번호로 식별, 해당 호스트의 프로세스는 포트 번호로 식별

## 애플리케이션이 필요한 트랜스포트 서비스
* 신뢰적인 데이터 전송(데이터 무결성: data integrity)

  * 몇몇의 (파일전송, 웹)등과 같은 앱들은 100%의 신뢰적인 데이터 전송를 요구한다.

  * 오디오나 비디오 같은 애플리케이션은 어느정도의 데이터 손실을 견딜 수 있다.

* 시간(timing)
  * (인터넷 전화, 게임)등과 같은 앱들은 짧은 전송 딜레이를 요구한다.
  
    * 여기서 딜레이는 source로 부터 destination까지 전송되는데 걸리는 시간이다.

* 처리량(throughput)

  * (오디오, 비디오)등과 같은 multimedia(다중매체) 스트리밍의 경우 단위 시간동안 일정량의 프레임을 전송해야한다.

  * 따라서 처리율의 최적화가 중요함

  * 탄력적 애플리케이션(elastic application)은 가용한 처리율이 많으면 많은 대로 적으면 적은 대로 이용한다.

    * 전자메일, 파일 전송, 웹 전송 등이 있다.

* 보안(security)

## 인터넷 전송 프로토콜이 제공하는 서비스
1. TCP(Transmission Control Protocl) 서비스
   1. 신뢰적인 데이터 전송 서비스
      1. 애플리케이션이 TCP프로토콜에게 데이터 전송을 부탁하면 애플리케이션은 내가 부탁한 데이터는 상대방에게 절대로 오류없이 순서대로 잘 도착할 것이라 확신할 수 있다. 

    2. 연결지향형(connection-oriented) 서비스
       1. TCP 클라이언트와 서버가 서로 핸드셰이킹 과정을 통해 전송 제어 정보를 교환한다.  

       3. 핸드셰이킹 과정이 클라이언트와 서버에 패킷이 곧 도착하니 준비하라고 알려주는 역할을 한다.

       5. 셰이킹 단계를 지나면, TCP연결이 두 프로세스의 소켓 사이에 존재한다고 얘기한다.

    3. 흐름 제어(flow control)
       1. sending TCP에서 너무 빠르게 데이터를 전송하게 되면 receiving TCP 버퍼가 가득 차게되는데 그러면 connection을 통해서 sending TCP에게 속도 조절을 요청하여 속도 조절을 함

    4. 혼잡 제어(congestion control)
       1. sendgin TCP와 receiving TCP 사이에는 네트워크가 있는데 네트워크의 여러 라우터의 홉 사이이의 통신시 라우터의 버퍼가 가득차게 되면 connection을 통해 sending TCP에게 요청하여 속도조절을 하게된다.

2. UDP(User Datagram Protocol) 서비스
   1. 신뢰적이지 않은 데이터 전송 서비스

## 애플리케이션 계층 프로토콜 정의

* 교환하는 메시지 타입을 정의
  * request 메시지, response 메시지

* 메시지의 문법을 정의
  * 메시지 내부의 필드와 필드 간의 구별법

* 메시지의 의미
  * 필드의 의미, 즉 필드에 있는 정보의 의미

* 규칙
  * 언제, 어떻게 프로세스가 메시지를 전송하고 메시지에 응답하는지 결정

### 프로토콜의 종류
* 개방 프로토콜
  * RFC(인터넷 표준)에서 정의하고 있음
  * ex) HTTP, SMTP

* 비개방 프로토콜
  * ex) Skype

<br/>

# 웹과 HTTP
* 웹 페이지(web page)는 객체(object)로 구성된다.

* 객체(object)는 HTML파일, JPEG 이미지, 오디오파일, 자바 애플릿 등이 될 수 있다.

* base HTML 파일이 웹 페이지를 구성하고 있는데 이 웹페이지는 몇몇의 객체를 참조하고 있는 형태이다.

* 각 객체는 URL형태이다.
  * www.someschool.deu/someDept/pic.gif  

    * home name부분 : www.someschool.edu  

    * path name부분 : /someDept/pic.gif

## HTTP란
hypertext transfer protocol의 약자이다.  

* 웹이라는 애플리케이션을 위해서 디자인된 프로토콜이다.

* 클라이언트/서버 구조
  
    * 클라이언트 프로세스 : 브라우져
      * HTTP 프로토콜을 사용하여 요청을 하고 응답을 받은 후 화면에 웹 객체를 출력한다.

    * 서버 프로세스 : 브라우져의 요청을 기다리고 요청이 오면 해당 응답을 반환한다.

* TCP를 사용한다.

  * 클라이언트 측에서 서버에게 TCP 연결을 시도한다.

    * 서버의 IP와 포트번호 80에 연결하기 위해 소켓을 생성한다.

  * 서버가 클라이언트 측의 TCP 연결 요청을 받아들인다.

  * TCP 연결을 통해 메시지를 주고 받는다.

  * TCP 연결이 닫힌다.

* HTTP는 비상태(staeless) 프로토콜이다.

  * 서버가 클라이언트가 보낸 요청을 저장하지 않는다.

    * 즉 유저가 이전에 보낸 요청이 무엇이었는지 서버는 전혀 기억하지 않는다.

## 지속(persistent) 연결과 비지속(non-persistent) 연결
최초의 HTTP는 non-persistent였다.  
non-persistent에 단점 때문에 persistent로 변경되었다.

* 비지속 연결(non-persistent) HTTP
  
  * 서버측에서 객체 하나를 보내주고 나면 바로 TCP 연결을 끊음
  
    * 웹 페이지는 하나의 객체로만 이루어지지 않는다.

  * 객체가 10개라면 웹페이지 1개를 받기 위해 TCP 연결을 10번 해야함 따라서 비효율적이다.

* 지속(persistent) HTTP

  * 한 번 TCP 연결을 맺으면 맺어진 TCP 연결을 통해서 여러 객체를 전달한다.


### 비지속(non-persistent) HTTP: 응답 시간
![image](https://user-images.githubusercontent.com/87526189/184528977-358c470e-0d04-420e-9592-1d22195d02d9.png)
* RTT(round trip time) : 작은 패킷이 클라이언트로부터 서버까지 가고, 다시 클라이언트로 되돌아오는 데 걸리는 시간

* HTTP 응답(response) 시간
  * TCP연결을 만들기 위해서 1RTT가 필요하다.

  * HTTP request를 보내고 첫 번째 바이트의 response를 받기까지 1RTT가 소요된다.

  * reponse의 마지막 바이트까지 전달 되어야 완료되므로 파일전송 시간(file transmission time)이 소요된다.

  * 비지속 HTTP 응답 시간 = 2RTT + 전체 파일 전송시간

response time은 웹 페이지 전체가 전달된 것은 아니다.  

base HTML만 도착한 것이다.  

만약 base HTML 이외에 5가지의 객체를 더 참조하고 있다면 추가적으로 5개의 객체가 다 와야지 웹 페이지 전체가 완성되는 것이다.  

비지속 HTTP의 경우에는 객체 하나를 받고나면 서버가 연결을 닫기 때문에 매 객체마다 TCP 연결을 다시 열어야한다.  

즉 각 객체마다 2RTT가 필요하다.

웹 페이지 하나를 다 받기 까지의 시간은 어떻게 될까?

### 지속(persistent) HTML
* 객체를 하나 내보낸 후에도 TCP 연결을 열어둔체로 놔둔다.

* TCP 연결을 위한 1RTT 소요

* base HTML을 보내기 위해 1RTT 소요

* 나머지 보내야할 객체를 한 번에 보내서 1RTT가 소요된다.

## HTTP 메시지 포맷
HTTP는 2종류의 메시지를 사용한다.  

### 1. 요청(requeset) 메시지
1. ASCII 코드로 표현되어 있다.
   
2. 구조

    ![image](https://user-images.githubusercontent.com/87526189/184542496-22bad173-e86b-41bf-bec3-53044c45ec7d.png)  

    * 요청라인(request line)

      * 방식 : 서버에게 어떤작업을 해달라 요청하는 곳

        * GET, POST, PUT ...

      * URL : 요청하는 파일의 URL

      * 버전 : 클라이언트가 사용하는 HTTP 버전

    * 헤더라인(header line)

      * 헤더필드 이름

        * ex) host

      * 값 

        * ex) 그 host의 이름

    * 공백라인

    * 개체몸체(entity body)

#### 서버에게 input값을 보내고 해당 input값에 대한 response를 받는 경우
    1. POST 메서드 : 개체몸체(entity body)에 input값을 담아서 보낸다. 

    2. URL 메서드 : URL에 "?_?_" 이런식으로 물음표 뒤에 담아서 input값을 보낸다.

#### 메서드 타입
1. HTTP/1.0
   1. GET : URL에 해당하는 페이지를 요청할 경우 사용

   3. POST : 입력값을 제공했을 때 그것을 반영하여 웹 페이지를 요청할 때

   5. HEAD : 서버에게 지금 요청한 URL에 해당하는 파일을 보내진 않아도 된다라는 의미 

      1. 즉 서버가 응답 메시지는 보내되 실제 요청한 객체(object)는 싣지 말고 보내라는 것이다.

      3. 개발하는 과정에서 테스트 목적으로 요청을 보내고 응답을 받아보려고 할 때 이것을 사용한다.

2. HTTP/1.1
   1. GET.POST,HEAD
   2. PUT : 클라이언트가 서버의 어떠한 URL에 파일을 업로드를 하는 것이다.
      1. 
   3. DELETE : URL field에 해당하는 파일에다가 delete하라고 서버에게 요청하는 것

### 2. 응답(response) 메시지
![image](https://user-images.githubusercontent.com/87526189/184549011-cb2d7271-8135-46e8-99fd-61cb33eee192.png)  

 상태라인(dtatus line)

  * 버전(version) : 서버의 HTTP 버전이 있다.

  * 상태코드(status code) : ex) 200, 400, 404...

  * 상태구문(status phrase) : ex) ok

* 해더라인(header line)

  * 헤더필드 : date, server, Last_Modified, connection ...

    * Date : 응답을 제공하는 시각

    * server : 서버의 종류

      * ex) Apache

    * Last_Modified : 서버가 제공하는 웹페이지가 마지막으로 수정된 시각

    * connection : ex) keep-Alive-> 객체를 보낸 다음에도 TCP를 닫지 않고 오픈한 상태로 있겠다는 의미

    * content-Length : 보내는 내용의길이가 몇 바이트인지

    * content-Type : 내용의 타입

      * ex) text/html

  * 값

* 공백라인

* 개체몸체 : 요청된 데이터를 body에 담음
  * ex) HTML 파일

#### HTTP 응답 상태코드
* 200 : 응답 메시지의 body에 가보면 요청된 객체가 실려있다는 의미
  
* 301 : 요청된 객체가 다른곳으로 옮겨져 저장되어 있다는 의미

* 400 : 요청 메시지가 잘못돼서 해석할 수 없다는 의미

* 404 : 요청된 웹 페이지가 웹서버에 없다는 의미

* 505 : 클라이언트의 HTTP 버전을 서버가 지원할 수 없다는 의미

## 사용자와 서버 간의 상호작용 : 쿠키(cookie)
앞서서 HTTP서버는 상태를 유지하지 않는다고 했다.  

하지만 웹 사이트가 사용자를 확인하는 것이 바람직할 때가 있다.  

이 목적으로 HTTP는 쿠키(cookie)를 사용한다.  

### 쿠키 기술의 4가지 요소
1. 서버측에서 HTTP 응답 메시지에 쿠키 헤더 라인을 집어 넣어서 보내줘야 한다.

2. 클라이언트측에서 요청을 보낼때도 쿠키 헤더라인을 포함시켜서 보내게 된다.

3. 브라우저(클라이언트)쪽에서는 쿠키 파일을 유지한다.

4. 서버측에서는 벡엔드 데이터베이스를 유지한다.

![image](https://user-images.githubusercontent.com/87526189/184567345-ba866635-360c-4e7d-aa41-6c104fd628f1.png)

### 쿠키를 통해 할 수 있는 일
* 인증

  * 매번 웹 사이트에 페이지를 요구할 때마다 인증을 새로해야하는 번거로움을 피할 수 있다.

* 쇼핑몰의 주문 담기

* 사용자의 세션(session)을 유지시켜 준다.(웹 메일)

  * 세션(session) : 컴퓨터 프로세서들 사이에서, 서로를 인식한 후에 데이터 송수신을 마칠 때까지의 기간.

## 웹 캐싱(chache) / (proxy server)
웹 캐시의 목적 : 캐시를 로컬 사이드 내에 둠으로써 오리지널 서버까지 가지 않고도 객체를 가져올 수 있게 하기 위함

* 캐시를 두는 경우 사용자의 브라우저는 언제나 캐시를 통해서 웹 접근을 하도록 설정을 해둔다. 
* 브라우저는 HTTP 요청을 캐시로 보내게 된다.
  * 객체가 캐시에 있는 경우 : 캐시로부터 객체를 반환 받음
  * 객체가 캐시에 없는 경우 : 객체 요청을 오리지널 서버에 요청을 하고 객체를 반환 받는다.

* 캐시는 서버도 되고 클라이언트도 된다.  

* 일반적으로 캐시는 대학교, 회사 등의 ISP에 의해서 설치된다.

### 왜 웹 캐싱을 사용할까?
* 클라이언트 요청에대한 응답시간을 단축시킬 수 있다.

* 해당 기관의 접근링크(access link) 트래픽 양을 줄일 수 있다.

* 자금이 넉넉치 않은 컨텐츠 제공자에게 비용을 절감시켜줄 수 있다.

### 조건부 GET
웹 캐싱이 사용자가 느끼는 응답 시간을 줄일 수 있지만 캐시 내부에 있는 객체의 복사본이 새것이 아닐 수 있다는 문제가 발생한다.  

즉 복사본이 클라이언트에 캐시된 이후에 웹 서버에 있는 객체가 갱신되었을 수 도 있다는 것이다.  

이때 HTTP는 모든객체들이 최신의 것임을 확인하면서 캐싱하는 방식을 **조건부 GET**이라고 한다.  

#### 조건부 GET 메시지 조건
1. GET 방식을 사용한다.

2. If-Modified-Since 헤더라인을 포함하고 있다.

#### 조건부 GET의 동작방식
1. 브라우저의 요청을 대신해 프록시 캐시는 요청 메시지를 웹 서버로 보낸다.

2. 웹 서버는 캐시에게 객체를 가진 응답 메시지를 보낸다.

3. 일주일 후에 다른 브라우저가 같은 객체를 캐시에게 요청하면 객체는 여전히 저장되어 있다. 이 객체는 지난주에 웹 서버에서 수정되었으므로 브라우저는 조건부 GET으로 갱신 조사를 수행한다.
   1. If-modified-since: 헤더 라인의 값이 이줄일 전에서버가 보낸 Last-Modified 헤더라인의 값과 저확히 일치하는 경우 body가 비어있는 응답을 반환한다.

4. 응답 메시지는 304 Not Modified상태 라인을 갖고 있고 이것은 클라이언트에게 요청 객체의 캐시된 복사본을 사용하라는 것을 의미한다.

<br/>

# 인터넷 전자메일

* 사용자 에이전트(User Agent)
  * 메일 메시지를 작성하고 편집하고 읽게 해주는 프로그램이다.
  * ex) Outlook, 아이폰 mail client, Gmail 등이 있다.

* 메일 서버(Mail Server)

  * 상대방에게 보내려고 작성한 메일이나 수신된 이메일 메시지를 메일 서버가 받는다.

  * 메일 서버는 2가지의 데이터 구조를 가진다.

    1. 메일박스 : 수신된 메일들을 담아두는 장소

       1. 사용자 구분을 하여 사용자별로 메일박스가 존재한다

    2. 메시지 큐(message queue) : 송신하는 메시지를 담고 있다.

       1. 사용자 구분을 따로 하지 않는다.

* 메일 프로토콜(Mail Protocol)

  * simple mail transfer protoco(SMTP) 라고 부른다.

  * 메일을 읽을때는 POP3, IMAP, HTTP 프로토콜을 이용하여 메일을 읽는다.

  * 메일의 시스템구성

    <img width="1084" alt="image" src="https://user-images.githubusercontent.com/87526189/184831178-019ff44c-ee66-470d-b1a1-5bef79728a69.png">  

    1. 이메일을 작성하면 사용자 에이전트가 송신측 메일 서버로 메시지를 보낸다.

       1. 그때 사용되는 프로토콜이 SMTP이다.

    2. 송신측 메일 서버로부터 수신측 메일 서버로 전달된다.

       1. 마찬가지로 SMTP릁 통해 보내진다.

    3. 수신측 메일 서버에 메시지가 들어오면 수신측 사용자 에이전트가 mail접근 프로토콜(POP,IMAP, HTTP..)등을 통해서 메시지를 읽어들인다

## SMTP

### SMTP 프로토콜
* 사용자 에이전트가 메일을 메일 서버측으로 송신하면

  * 클라이언트 : 유저 에이전트

  * 서버 : 메일 서버

* 메일 서버가 수신측 메일서버로 송신하면

  * 클라이언트 : 송신측 메일 서버

  * 서버 : 수신측 메일 서버

* TCP 위에서 동작한다.

* SMTP 서버 프로세스는 포트번호 25번을 사용한다.

* SMTP의 대략적인 전송 3단계

  1. 핸드셰이킹(greeting) 단계

  2. 메시지 전송 단계

  3. 종료 단계

* 클라이언트는 명령어(command)가 들어가있고 서버의 메시지에는 응답(response)이 들어가있다.(HTTP,FTP와 유사)

  * 명령어(command) : ASCII 텍스트로 구성

  * 응답(response) : 상태코드와 구문

* 이메일 메시지는 반드시 ASCII 텍스트 메시지로 구성되어야 한다.

### SMTP 상호작용
    s: 220 hamburger.edu                                     //나는 hamburger.edu이야 //greeting 단계 시작
    c: HELO crepes.fr                                        //안녕 나는 crepes.fr이야
    s: 250 Hello crepes.fr, pleased to meet you              //crepes.fr안녕 만나서 반가워 //여기까지가 핸드셰이킹 greeting 단계가 완료
    c: MAIL FROM: <alice@crepes.fr>                          //alice@crepes.fr에서 메일을 보냈어 //메시지 전송 단계 시작
    S: 250 alice@crepes.fr... Sender ok                      //OK 대답해준다.
    c: RCPT TO: <bob@hamburger.edu>                          //RCPT : Recipient 받는사람을 의미 -> 수신자가 누구인지 명시
    s: 250 bob@hamburger.edu ... Recipient ok                //수신자 확인 완료
    C: DATA                                                  //이제 데이터를 보낸다는 신호
    S: 354 Enter mail, end with "." on a line by iterself    //메시지의 끝은 "."로 표시를 해달라고 요청
    C: Do you like ketchup?                                  //사용자가 쓴 메시지1
    C: How about pickles?                                    //사용자가 쓴 메시지2
    C: .                                                     //메시지의 끝을 알림 //메시지 전송단계 끝
    S: 250 Message accepted for delivery                     //여기까지가 메시지 전송 단계 완료 //종료 단계 시작
    C: QUIT                                                  //메시지를 다 보냄
    S: 221 hamburger.edu closing connection                  //연결을 닫음 //종료 단계 끝

### SMTP 와 HTTP의 차이점
* HTTP : pull
* SMTP : push

* 둘 다 ASCII로 된 명령/응답을 한다.

* HTTP : 하나의 응답에 하나의 객체를 실는다. 

* SMTP : 한 번 greeting 후에 한 메일에 여러 파일들로 구성됐을 때도 한꺼번에 다 실을 수 있다.  

<br/>

---
# 3주차

## 메일 접속 프로토콜(mail access protocol)
![image](https://user-images.githubusercontent.com/87526189/185573484-59deb2df-4447-40d9-b985-2afcbec98b92.png)

push : 송신측 사용자 에이전트A -> 전송 메일 서버 -> 수신 메일 서버 과정을 거친다.  

pull : 수신 매일 서버 -> 수신측 사용자 에이전트B

### 메일 접속 프로토콜의 종류
* POP : Post Office Protocol[RFC 1939]의 약자이며 가장 단순한 프로토콜

* IMAP : Internet Mail Access Protocol[RFC 1730]의 약자이고 POP의 단점을 보완한 매우 복잡한 프로토콜

* HTTP : 수신측 메일 서버가 웹메일인 경우 HTTP 프로토콜을 이용해서 웹 메일을 가져오기도 한다.

### POP3 프로토콜
<img width="320" src="https://user-images.githubusercontent.com/87526189/185606257-9ebf3841-a2e4-4519-9b41-5e047e0b378c.png">  

#### POP3프로토콜의 진행과정

* 인증단계(authorization phase)
  * 클라인언트는 명령을 내림
    * user : 사용자 이름
    * pass : 비밀번호

  * 서버는 응답을 함
    * +OK
    * -ERR

* 트랜잭션 단계(tracsaction phase)
  * list : 메시지 번호와 바이트 사이즈를 반환 하고 .이 오면 메시지의 끝임을 표시한다.
  * retr : 번호를 사용하여 메시지를 검색한다.
  * dele : 번호를 통하여 삭제를 한다.
  * quit : 서버에게 통신을 끊기를 요청
  
<br/>

#### POP3는 2가지의 모드가 있다.
* 다운로드 후 삭제모드

  * retr후 dele를 수행

  * ex) 회사에서 메일 3개를 읽어오면 집에 돌아가고나서는 회사에서받은 메일 3개를 제외하고 새롭게 도착한 메일만 읽을 수 있다.

* 다운로드 후 유치모드

  * 다운로드 후 삭제모드와 다르게 retr후 dele를 수행하지 않고 list파악 후 차례대로 list에 있는 모든 메시지들을 retr하고 quit하게 된다. 

  * ex) 메일 메시지들이 메일 박스에 그대로 유지되어서 다른 곳에서 읽어도 아까 읽었던 메시지가 다시 그대로 새 메시지인 것 처럼 (retreive)되찾아올 수 있다.

* POP3는 세션의 상태를 유지하지 않기 때문에 지난번 세션에서 이 사용자가 어떤 메시지를 retreive를 했는지 서버는 전혀 기억을 하고 있지 않는다.

### IMAP
POP3의 다운로드 후 삭제모드와 다운로드 후 유치모드 둘 다 불편한 부분이 존재하여 만들어진 프로토콜이 IMAP이다.  

메일 서버의 박스에다가 사용자가 하는 일 모두 반영한다.
즉 서버의 메일박스에다가 작업을 하게 되는 것이다.

* 모든 메시지들이 서버에 유지가된다.

* 서버의 메일박스에다가 폴더를 생성할 수 있다.

* 한 세션에서 작업한 것(특정 메시지를 다른 폴더로 옮기거나 메시지를 삭제하는 등등)을 다음 세션을 열었을 때 그대로 메일박스에 이미지가 그대로 유지되고 있다.

# DNS(Domain Name System) 인터넷 디렉터리 서비스
인터넷 호스트를 식별하는 방법에는 2가지가 있다.
1. 사람이 인터넷 호스트를 식별하는 방식인 호스트 네임(hostname)
   1. ex) www.facebook.com

2. 라우터가 식별하기 편한 방식인 IP주소(32bit)
   1. ex) 121.7.106.83

DNS는 호스트 네임과 IP주소를 매핑해주는 역할을 한다.

### Domain Name System
* 광범위한 데이터베이스를 사용한다.

  * 많은 damin name server의 계층속에서 분산되어 수행되는 분산데이터베이스이다.

* 애플리케이션 계층 프로토콜이다.

  * 모든 애플리케이션은 호스트네임->IP주소로 매핑하는 과정을 거치게 되므로 네트워크 계층 프로토콜로 처리해주는 것이 옳다고 생각할 수 있다. 하지만 네트워크 계층은 가장 심플한 패킷을 전달해주는 일만 수행하도록 만들기 위해서 즉 모든 복잡한 일은 edge로 몰아내기 위해서 애플리케이션으로 처리하도록 구현했다.

## DNS가 제공하는 서비스와 구조
### DNS 서비스
* 호스트네임을 IP주소로 변경하는 서비스를 제공한다.

* 호스트 엘리어싱(host aliasing)(별칭) 서비스

  * alias name을 정식 호스트 네임(canonical hostname)으로 변환해주는 서비스를 제공한다.

* 메일 서버 엘리어싱(mail server aliasing)

  * DNS는 제공된 별칭 호스트 네임에 대한 정식 호스트 네임을 얻기 위해 메일 애플리케이션에 의해 수행된다.

* 부하 분산(load distribution)

  1. 인기 있는 사이트는 여러 서버에 중복되어 있어 각 서버가 다른 종단 시스템에서 수행되고 다른 IP주소를 갖는다.  

  2. DNS 데이터베이스는 이 IP 주소 집합을 가지고 있다.

  3. 클라이언트가 주소 집합으로 매핑하는 호스트 네임에 대한 DNS 질의를 하면, 서버는 IP 주소 집합 전체를 가지고 응답하여 주소를 순환식으로 보낸다.

  4. 따라서 트래픽을 분산하는 효과를 가진다.


## 분산 계층 데이터베이스
DNS 서버는 서버 사이에 분산된 세 유형의 DNS 서버가 있다.  

1. 루트(root) DNS 서버

3. 최상위 레벨 도메인 네임(TLD, top-level domain)DNS 서버

5. 책임(authoritative) DNS서버

### 분산 계층 데이터베이스 동작원리
![image](https://user-images.githubusercontent.com/87526189/185639886-fb7e9f75-41e6-4a9a-a3c5-e2ea8a4a4726.png)  
DNS 클라이언트가 호스트 네임 www.amazon.com의 IP주소를 결정하기 원한다고 가정한다.  

1. 클라이언트는 루트 서버 중 하나에 접속한다.

2. 루트 서버는 최상위 레벨 도메인 com을 갖는 TLD서버 IP주소를 보낸다.
  
3. 클라이언트는 이 TLD 서버 중 하나에 접속한다.
   
4. 서버는 도메인 amazon.com을 가진 책임 서버의 IP 주소를 보낸다.

## 로컬 DNS 서버
* 위의 계층구조에 엄격하게 속하지 않는다.

* 대학이나 주거지역 ISP와 같은 ISP들은 로컬 DNS 서버를 가진다.

* 호스트가 DNS 쿼리를 만들어내면 쿼리는 로컬 DNS 서버로 보내진다.

  * 로컬 DNS 서버가 쿼리에 대한 매핑정보를 캐싱하고 있다면 그것으로 응답함

  * 없다면 계층 DNS 시스템으로 쿼리를 던진다.

### 최상위 레벨 도메인 네임(TLD), 책임(authoritative) 서버
* top-level domain(TLD) 서버

  * com, org, net, edu, aero, jobs 등과 같은 도메인을 각각 담당한다.

  * uk, fr, ca, jp ,kr 등과 같은 국가 domain server를 TLD에서 담당한다.

  * TLD를 관리하는 기관이 존재하는데 .com같은 경우 Network Solutions라는 기관이 관리한다.

  * .edu TLD는 Educause for이라는 기관이 관리한다.

  * .kr을 관리하는 기관은 한국인터넷정보센터이다.

* authoritative DNS 서버

  * 조직 자신의 DNS 서버를 의미한다.

  * TLD에 의해 관리되어지는 DNS 서버이다.

  * 조직에 속해있는 호스트네임을 IP와 매핑해준다.

### 루트 네임 서버
* TLD 서버를 관리하는 서버이다.

* 로컬 DNS 서버가 host name에 대한 정보를 가지고 있지 않을 때 제일 먼저 컨택하는 서버이다.

### DNS 서버의 상호작용
* 반복적 질의(iterative query)

  * 질의를 받은 서버가 자기가 매핑정보 자체는 제공하지 않고 누구를 컨택해야할 지만 알려줌  
  <img width=300 src="https://user-images.githubusercontent.com/87526189/185649023-65df9f80-25f9-431e-b237-0cdc24102efb.png">

* 재귀적 질의(recursive query)

  * 서버가 질의를 받으면 어떻게 해서든 자기가 그 매핑정보를 구해서 질의한 호스트에게 답을 해준다.  
  <img width=300 src="https://user-images.githubusercontent.com/87526189/185649607-fb578846-d630-4c79-9b6f-4a6905274be8.png">

## DNS 캐싱
* 일반적으로 로컬 네임 서버는 TLD 서버를 캐싱하고 있다.

* 유효 기간이 지난 정보로 답을 할 수 있다는 문제를 가지고 있다.

  * 매핑정보에는 항상 TTL(Time to leave)정보를 가진다.

    * TTL 시간동안만 유지하고 시간이 지나면 버린다.

* IETF 표준에서는 어떠한 로컬 사이트에서 name에서 IP로의 매핑이 변경 됐다면 세상에 업데이트하고 알리는 메커니즘이 제안되었다.

### DNS 프로토콜 메시지 포맷
![image](https://user-images.githubusercontent.com/87526189/185653428-b622fc76-186f-43b4-8d81-c1a32a6dced7.png)  
* 메시지의 종류는 요청(query)과 응답(reply) 2개이다.

  * 요청과 응답 메시지는 같은 포맷을 사용한다.

#### 메시지 헤더
* 식별자(identification) : 요청과 응답은 같은 식별자를 사용하여 짝을 이룬다.

* 플래그(flag) : 

  * 요청인지 응답인지 나타냄

  * 재귀적으로 처리하길 희망하는지 나타냄

  * 서버의 경우 재귀적으로 처리할 수 있음을 나타냄

  * 응답에 실려있는 정보가 책임(authoritative) 서버일 경우 응답 메시지에 설정된다.

#### 메시지 필드
헤더에 4개의 "개수" 필드가 있다.  

* 질문 영역 : 현재 질의에 대한 정보를 포함한다.

  * 질의되는 이름을 포함하는 이름필드

  * 이름에 대해 문의되는 질문 타입을 나타내는 타입 필드

* 답변 영역 : 원래 질의된 이름에 대한 자원 레코드를 포함한다.

## DNS 레코드
* DNS : 분산 데이터베이스 저장공간에 자원 레코드를 가지고 있다.  

* 자원 레코드(resource recodrd)(RR) : 데이터베이스에 저장하는 정보

* RR 포맷 : name, value, type, ttl

  * type=A

    * name : 호스트 네임

    * value : IP 주소

  * type=CNAME

    * name : 별칭(alias)

    * value : 정식 호스트 네임(canonical hostname) 

    * ex)www.ibm.com 의 실제 이름은 servereast.backup2.ibm.com

  * type=NS

    * name : 도메인 네임

    * value : 이 도메인을 담당하는 네임 서버

  * type=MX

    * name : 도메인 네임

    * value : 메일 서버

### 각 DNS 서버에서 RR에 저장되는 것
* 루트 DNS 서버 : 각 top level domain(TLD)에 대해서 그 도메인을 담당하는 TLD DNS 서버가 누구인지 저장하고 있다.
  * .com을 담당하는 TLD서버 이름
  * .edu를 담당하는 TLD서버 이름

* TLD DNS 서버 : .com 담당하는 TLD 서버라면 .com안에 있는 모든 기관을 담당하는 authoritative DNS 서버의 이름이 뭔지 저장하고 있다.

* authoritative(책임) DNS 서버 :  자기 기관 내에 속해있는 모든 호스트에 대해서 호스트네임-IP 매핑정보를 가지고 있다.

<br/>

# P2P 애플리케이션
## 순수한 P2P 구조
* 항샹 켜져있는 서버를 사용하지 않는다.
* 임의의 end system들이 직접 통신한다.
* 이때 이 end system(종단시스템)을 peer라고 부른다.
* Peer는 네트워크에 연결됐다가 끊어졌다가 하고 이때 IP주소가 간간이 변경된다.

### P2P구조 애플리케이션
* 파일 분배 시스템(비트토렌트)
* VoIP(Skype)
* 스트리밍 시스템(KanKan)
 
파일을 원하는 클라이언트가 늘어나면 그와 더불어 파일을 업로드 할 수 있는 능력도 늘어나기 때문에 결국 원하는 클라이언트 수에 비례해서 파일 업로드 시간이 늘어나지 않는다.  

따라서 확장성이 좋다.  

### 비트토렌트(BitTorrent)
파일 분배를 위한 인기 있는 P2P프로토콜이다.  

* 파일을 256Kb 덩어리로 나눈다.

* 토렌트 속 peer들은 파일 덩어리를 주고 받는다.

  * 토렌트(torrent) : 파일의 덩어리를 교환하는 사용자의 그룹이다.

  * 트랙커(tracker) : 각 토렌트에 속하는 peer들이 누구인지 추적한다.

  * 청크(chunk) : 파일 덩어리

#### 비트토렌트:동작예시
![image](https://user-images.githubusercontent.com/87526189/185772089-6608ebeb-a270-4e62-b821-8acf83e1046b.png)  
1. 사용자는 트랙커를 먼저 컨택하여 트랙커로부터 현재 자기가 원하는 파일에 해당하는 토렌트에 속하는 peer들이 누가 있는지 리스트를 받는다.

3. 리스트에 있는 Peer들로부터 청크(chunk)를 공급받는다.

   1. 청크를 가지고 있지 않지만 시간이 지나면서 다른 peer에게 청크가 누적된다.

5. 다운로드 하는동안 peer는 다른 peer들을 위해 청크를 업로드한다.

7. peer가 청크를 교환하는 peer를 변경할 수 있다.

9. churn : 피어가 없어지기도 하고 새로 들어오기도 하는데 이러한 피어의 변화를 말한다.

   1. churn이 P2P시스템에서 문제가 된다.

11. 어느 한 peer가 파일 전체를 가지면 이기적이게 떠나거나 이타적으로 토렌트에 남을 수 있다.

#### 비트토렌트: 파일 청크의 요청, 응답
* 요청 청크 :

  * peer는 정기적으로 이웃peer에게 청크 리스트를 요청한다.

  * peer는 요청에서 누락된 청크를, rarest first로 받는다.

    * rarest first : 이웃들 중 가장 적은 반복 복사본을 가진 청크

* 응답 청크: TFT(tit-for-tat)

  * TFT(tit-for-tat) : 자신에게 잘 공급해주는 peer에게 자신도 잘 공급해주는 것

    * 이기적인 peer가 살아남지 못하게 하는 시스템이다.

  * 각 peer는 10초마다 나에게 공급을 잘해주는 top 4 peer를 선정한다.

    * 그 top 4 peer에게 자신도 열심히 제공을 해준다.

  * 매 30초마다 무작위로 아무 peer나 선책하고, 청크를 보내본다.

    * 그러다 top 4 peer로 선정된다면 새롭게 peer가 변경된다.

    * 그러면 peer는 더 좋은 파트너를 구할 수 있게 된다.

<br/>

#
















































<br/>

# Reference
네트워크 강의  
http://www.kocw.net/home/cview.do?cid=e44bdd9b3a3f9bb5  

교재  
Computer Networking A Top Down Approach, 7th, converted / james F. Keith W.Ross  
컴퓨터 네트워크(하향식접근) / james F. Keith W.Ross
