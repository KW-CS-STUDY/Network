# NetWork
1. [인터넷이란?](#인터넷이란)
2. [프로토콜이란?](#프로토콜이란)
3. [네트워크 가장자리(network edge)](#네트워크-가장자리network-edge)
4. [네트워크 코어(중심부/network core)](#네트워크-코어중심부network-core)
5. [프로토콜 계층과 서비스 모델](#프로토콜-계층과-서비스-모델)
---
6. [애플리케이션 아키텍처](#애플리케이션-아키텍처)
7. [웹과 HTTP](#웹과-http)
8. [인터넷 전자메일](#인터넷-전자메일)
---
9.  [DNS(Domain Name System) 인터넷 디렉터리 서비스](#dnsdomain-name-system-인터넷-디렉터리-서비스)
10. [P2P 애플리케이션](#p2p-애플리케이션)
11. [소켓 프로그래밍](#소켓-프로그래밍)
---
12. [트랜스포트 계층 서비스 및 프로토콜](#트랜스포트-계층-서비스-및-프로토콜)
13. [다중화(Multiplexing)와 역다중화(demultiplexing)](#다중화multiplexing와-역다중화demultiplexing)
14. [UDP: User Datagram Protocol](#udp-user-datagram-protocol)
15. [TCP: transmission control protocol](#tcp-transmission-control-protocol)
16. [혼잡제어(congestion control)의 원리](#혼잡제어congestion-control의-원리)
17. [TCP 혼잡제어(congestion control)](#tcp-혼잡제어congestion-control)
---
18. [네트워크 계층 개요](#네트워크-계층-개요)
19. [라우터 아키텍처](#라우터-아키텍처)
20. [인터넷 프로토콜(IP):IPv4, 주소지정,IPv6](#인터넷-프로토콜ipipv4-주소지정ipv6)

# 일정
1. 2주차
   1. 3-1(애플리케이션 계층) 네트워크, 애플리케이션, 웹 과 http 원리
   2. 3-2(애플리케이션 계층) HTTP
   3. 4-1(애플리케이션 계층) FTP, 전자우편(Electronic mail) SMTP
2. 3주차
   1. 5(애플리케이션 계층) 전자우편(Electronic mail) POP3,IMAP,DNS
   2. 6(애플리케이션 계층) P2P 애플리케이션
   3. 6-2(애플리케이션 계층) UDP와 TCP를 통한 소켓프로그래밍 및 트랜스포트 계층 서비스, Multiplexing Demultiplexing
3. 4주차
   1. 7(트랜스포트 계층) 비연결형 트랜스포트:UDP, 신뢰성있는 데이터전송의 원리, 연결지향형 트랜스포트:TCP
   2. 8(트랜스포트 계층) 연결지향형 트랜스포트:TCP
   3. 9(트랜스포트 계층) 혼잡제어의 원리
4. 5주차
   1. 9-2(네트워크 계층) 가상회선과 데이터그램, 네트워크
   2. 10(네트워크 계층) 라우터 내부
   3. 10-2(네트워크 계층) IP:인터넷 프로토콜
5. 6주차
   1. 11(네트워크 계층) 라우팅 알고리즘
   2. 12(네트워크 계층) 인터넷 속 라우팅, 
   3. 13 브로드케스트 멀티케스트 라우팅
6. 7주차
   1. 14(링크 계층)
   2. 15 무선과 모바일 네트워크

---




# 1주차
# 인터넷이란? 
## 인터넷의 구성요소
1.  네트워크의 가장자리(network edge)

    * 컴퓨터 or 서버 -> ("host" or "end system")이라 부름

2.  네트워크 코어(network core)

    * 라우터(스위치) : 사용자에게 전달되어야할 메시지를 목적지에 찾아갈 수 있게 하는 역할


3. 링크 : 물리적인 실제 회선  

<br/>

* 인터넷(Internet) : 네트워크들 속에서의 네트워크 -> 즉 네트워크들이 모인 곳에서의 네트워크를 말함

### 프로토콜(Protocols) : 인터넷에서 메시지를 보내고 받는 규칙

  * 인터넷 통신을 하기 위해서는 프로토콜 표준화가 매우 중요함

  * ex) TCP, IP, HTTP, Skype, 802.11 ...

### 인터넷 표준화(Internet standards)

  * IETF(Internet Engineering Task Force) : 인터넷 프로토콜의 표준화 기관

  * RFC(Request for comments) : IETF에서 RFC라는 표준안을 발표함

<br/>

# 프로토콜이란?
보내고 받는 메시지의 형식(format), 순서(Order), 액션(action)을 정의(약속)한다. 

<br/>

# 네트워크 가장자리(network edge)
* 종단 시스템(end system) : 인터넷에 연결되는 컴퓨터와 다른 장치들은 인터넷의 가장자리를 차지하고 있기 때문에 end system이라 한다.

	* ex) **데스크톱**(데스크톱 PC, 매킨토시, 리눅스 컴퓨터...), **서버**(웹과 전자메일 서버), **모바일 컴퓨터**(스마트폰, 태블릿, 랩톱)...

* 호스트(host) : 네트워크 애플리케이션을 호스팅하고 있는 end system을 지칭하는 말

	* 클라이언트 와 서버로 구분 

## 접속 네트워크(access network)
host 혹은 end system들을 네트워크에 연결시켜주는 놈

### access network를 구분짓는 요소

1. bandwidth(대역폭)
   
2. 다른 사람과 공유를 하는지 공유 유무

### access network 종류

1. DSL : Digital Subscriber Line, 전화선을 이용한 인터넷 서비스, 현재는 잘 쓰이지 않음

2. 케이블(cable) network : 케이블로 연결한 네트워크 서비스

3. home network : 집 내부에 구성하고 있는 네트워크
   1. 데스크톱을 home network 연결 -> home network을 케이블회사 or DSL(전화회사) 연결

4. 무선(Wireless) 네트워크
   1. 무선 랜(LAN) : 802.11b/g(WiFi)
   2. 광대역 무선 네트워크 : 셀룰러(3G, 4G, LTE)

<br/>

# 네트워크 코어(중심부/network core)
source에서 destination으로 사용자의 애플리케이션 메시지를 전달해 주는 것이 목표이다.  

### 전달해 주는 방식
1. 회선교환(packet switching)

2. 패킷교환(circuit switching )

## 회선교환(circuit switching)
<img width="431" alt="스크린샷 2022-08-05 오후 12 38 50" src="https://user-images.githubusercontent.com/87526189/183372743-f44c2142-350b-4979-ab7b-1778c9cafc70.png">  

주로 전화 네트워크에서 사용되는 방식으로 user가 call을 하면 call set up 과정을 거쳐서 둘 사이에 파이프로 연결된 것 처럼 연결할 수 있다.

### call set up에서 하는 일
1. source -> destination 전달되는 경로를 결정함(어떤 라우터 스위치를 경유할 것인지)
 
2. 그 경로상의 자원이 예약됨

경로상의 자원은 한정적이기 때문에 분할하여 여러사용자가 사용할 수 있도록 한다.

### 네트워크 자원을 분할하는 방법
1. FDM(frequency division multiplexing) : 주파수 분할 다중화

	* 주파수 대역폭을 기준으로 사용자별로 다른 대역을 할당해 준다

2. TDM(Time division multiplexing) : 시 분할 다중화 

	* 링크에 가용한 대역폭 전체를 사용자들이 사용할 수 있게 하되 시간을 기준으로 잘라서 시간을 할당함

## 패킷교환(packet switching)
circuit switching은  전화에서는 지속적인 연결이 필요하므로 적합했지만 컴퓨터 간의 통신에서는 데이터 네트워크인 인터넷에서는 Request가 올 때는 대량의 데이터가 발생하지만 한 동안은 데이터가 발생하지 않는다.  

따라서 circuit switching은 인터넷과 같은 데이터 네트워크에서는 비효율적이다. 그래서 등장하게 된 것이 packet switcing이다.

### 패킷교환(packet switcing)의 주요 개념
1. 예약이 없다. -> No call set up / No resource reservation
	* 필요가 발생하면 그때그때 마다 resource를 사용할 수 있게 한다.

2. 데이터를 패킷으로 잘라야한다.

3. 패킷의 목적지 주소가 명시되어 있어야한다.(예약어가 없기 때문)
	* 라우터는 패킷을 받으면 패킷의 목적지 주소를 보고 다음 라우터의 위치를 결정한다.  

4. 저장 후 전달 전송(store-and-forward)
	* 각 라우터는 패킷 하나를 다 받아야지만 목적지 정보를 파싱하고 다음 위치로 보낼 수 있기 때문에 패킷 전체가 도달 할 때 까지는 일단 받는 작업만 한다.

### 큐잉지연(queueing delay) 과 패킷 손실(loss)
패킷 스위치는 출력 버퍼를 가지고 있고, 링크로 송신하려는 패킷을 저장하고 있다.  

패킷이 한 링크로 전송하려고 했는데 그 링크가 다른 패킷을 전송하고 있다면, 도착한 패킷은 출력 버퍼에서 대기한다.  

이때 패킷은 출력버퍼에서 큐잉지연(queueing delay)을 겪게된다.  

버퍼의 공간은 유한하기 때문에 패킷으 로 꽉 차있을 수 있으며 이 경우 다른 패킷이 도착하면 패킷손실(packet loss)가 발생한다.  

<br/>

# 프로토콜 계층과 서비스 모델
인터넷은 매우 복잡한 시스템이다.  

인터넷은 다양한 애플리케이션과 프로토콜, 여러가지 종단 시스템(End System)과 종단 시스템 간의 연결, 라우터, 다양한 링크 수준의 매체가 있음을 보았다. 

이러한 복잡한 네트워크 구조를 어떻게 조직화 할 수 있을까?  

## 계층구조(layering)
프로토콜은 매우 방대하고 복잡하기 때문에 계층구조로 되어있다. 

### 계층구조의 장점
1. 복잡한 시스템의 조각들을 식별하고 그것들 관의 관계를 정의하는 것이 용이해진다.  

2. 업데이트와 유지보수가 쉬워진다.

    * 방대한 프로그램을 하나의 함수로 구현하면 유지보수하기 어려울 것이다. 하지만 기능별로 나눠서 함수로 구현하게 되면 유지보수하기 용이해질 것이다. 마찬가지로 방대한 프로토콜 시스템을 계층으로 나누면 유지보수와 업데이트하기 쉬워진다.

### 계층구조의 단점
1. 계층의 기능을 독립적으로 계층의 목적을 정의하고 목적에 맞춰서 기능을 구현하다보면 그 기능들 간에는 서로 겹쳐지는 부분이 발생할 수 있다.

2. 한 계층에서 최적으로 작동하기 위해서는 다른 계층에서 수집하고 있는 정보나 다른 계층에서만 알려지게되는 정보를 필요로 할 수 있다. 그럴때 엄격하게 계층을 구분해 놓으면 두 계층간에 커뮤니케이션이 있어야만 다른 계층에서 발생한 정보를 가져올 수 있기 때문에 오버헤드가 발생할 수 있다. 
 
     * -> 즉 어떤 계층의 기능을 구현하는 것이 최적이지 않을 수 있다.

### 인터넷의 5개 계층의 프로토콜 스택

![image](https://user-images.githubusercontent.com/87526189/183373019-709901a2-835a-4f8b-9bb6-d76a08aaa002.png)

1. 애플리케이션(application) : 네트워크 애플리케이션 프로그램을 지원하는 역할

    * 유저가 애플리케이션 프로그램에서 발생시킨 데이터를 어떻게 메시지로 만드느냐 하는 것이 애플리케이션 계층의 주된 역할

    * ex) web 애플리케이션 -> HTTP라는 프로토콜이 web 애플리케이션 프로그램을 지원하고 있다.

    * ex) email -> SMTP프로토콜

    * ex) 파일전송(file transfer) -> FTP

2. 트랜스포트(transport)

    * 애플리케이션 프로그램에서 만들어진 메시지를 목적지 프로그램으로 전달해주는 역할

    * process to process 전송을 수행하는 계층

    * TCP와 UDP라는 트랜스포트 프로토콜이 있음

3. 네트워크(network)

    * 트랜스포트 계층에서 process to process 전송을 수행하기 위해 host to host 전송을 네트워크 계층에게 부탁함

    * 라우팅(길찾기)을 통해 source host(SH)로 부터 destination host(DH)까지 배달해줌

4. 링크(link)

    * SH에서 DH까지 배달하기 위해서 hop by hop으로 네트워크 노드를 거쳐가야한다. 한 hop 전달하는 것을 링크에게 부탁함

5. 물리(physical)
   
    * 링크 계층에서 한 hop을 건너가기 위해 물리계층에게 transmission medium에다가 데이터를 실어 나르는 일을 부탁함

각 계층은 바로 아래 계층의 서비스를 이용하여 자신의 프로토콜 계층의 목표를 달성하게 된다.  

### **OSI 7계층의 모델**
위 프로토콜 스택이 유일한 프로토콜 스택이 아니다.  

1970년대 후반 ISO(International Organization for Standardization)은 컴퓨터 네트워크가 7계층으로 구성되어야 한다는 제안을 했는데 이를 OSI(Open System Interconnection)라고 부른다.

![image](https://user-images.githubusercontent.com/87526189/183402540-3b432c41-193a-4230-80ab-66c55f3d7ca2.png)

이들 계층 중 5개 계층의 기능은 비슷하게 이름 붙여진 인터넷 계층과 거의 비슷하 다. 따라서 OSI 참조 모델에 있는 2개의 추가 계층들(프레젠테이션 계층과 세션 계층) 만 살펴본다.

1. 프레젠테이션 계층 : 통신하는 애플리케이션들이 교환되는 데이터의 의미를 해석하도록 하는 서비스를 제공하는 것이다. 이들 서비스는 데이터 기술 뿐만 아니라 데이터 압축과 데이터 암호화를 포함한다.

2. 세션 계층 : 데이터 교환의 경계와 동기화를 제공한다. 이에는 체킹포인트와 회복 방법을 세우는 수단을 포함한다.

인터넷이 OSI참조 모델에서 찾을 수 있는 2개 계층이 없다는 사실은 두 가지 질문을 하게 만든다.  

1. 이들 계층이 제공하는 서비스는 중요하지 않은가?

2. 애플리케이션이 이 두 서비스중 하나를 요구하면 어떻게 되는가? 

<br/>

이에 대한 대답은 애플리케이션 개발자에게 달려있다.  

그 서비스 가 종요하다면 기 기능을 애플리케이션에 넣는 것은 애플리케이션 개발자에게 달려있다.
 
## 캡슐화(Encapsulation)
![스크린샷 2022-08-08 오후 8 04 58](https://user-images.githubusercontent.com/87526189/183404129-28e76109-c366-4940-a409-80322f1d575d.png)

### 세그먼트
애플리케이션 계층 메시지는 트랜스포트 계층으로 보내진다.  

트랜스포트 계층은 메시지에 수신 측 트랜스포트 계층에서 사용될 추가 정보(헤더 정보)를 더한다.  

애플리케이션 계층 메시지와 트랜스포트 계층 헤더정보는 모두 트랜스포트 계층 세그먼트를 구성한다.

트랜스포트 계층 세그먼트는 애플리케이션 계층 메시지를 캡슐화한다.

### 데이터그램
트랜스포트 계층은 세그먼트를 네트워크 계층으로 보내며 네트워크 계층은 출발지와 목적지 종단 시스템 주소와 동일한 헤더 정보를 추가하여 네트워크 계층 데이터그램을 만든다

### 프레임
데이터그램은 링크 계층으로 전달되고 링크 계층도 자신의 헤더 정보를 추가하고 링크 계층 프 레임을 만든다.

<br/>

---------------------------------------------------
# 2주차

# 애플리케이션 아키텍처
현대의 네트워크 애플리케이션과 네트워크 애플리케이션을 지원하는 애플리케이션 프로토콜은 2가지 중 하나의 아키텍처를 가진다.
1. 클라이언트-서버

2. P2P 아키텍처

## 클라이언트-서버 아키텍처
* 서버(server)
  * 항상 켜져있는 호스트를 서버라 함
  
  * 영구적으로 할당된 IP주소를 가지고 있는 호스트이다.

  * 클라이언트가 많을 때는 각각의 클라이언트를 응대하기 위해 데이터 센터형식으로 동일한 기능을 하는 서버가 군집되어 있는 형태로 존재

* 클라이언트(client)
  * 서버와 통신을 함

  * 인터넷에 간혈적으로 연결된다.

  * 동적인(dynamic) IP주소를 할당 받는다.
    * 인터넷에 연결될 때마다 변경이 가능한 주소를 말함

## P2P 아키텍처
* 항상 켜져있는 서버를 사용하지 않는다.

* 커뮤니케이션 하는 호스트를 peer라고 부름
  * peer는 다른 호스트로부터 요청하기도 하고 다른 peer에게 서비스를 제공해주기도 한다.
  
    * 자가 확장성(self-scalability)을 가진다.

* peer들은 간혈적으로 연결되고 IP가 변경되기 때문에 관리가 매우 복잡하다.

<br/>

# 프로세스 간 통신
서로 다른 호스트 간의 프로세스들 사이에서 메시지를 통해 통신을 한다.

## 통신하는 프로세스의 종류
1. 클라이언트 프로세스 : 통신을 시도하는 프로세스

2. 서버 프로세스 : 대기하고 있다가 클라이언트의 접근을 받아서 응답함

## 프로세스와 컴퓨터 네트워크 사이의 인터페이스

### 소켓(Socket)
![image](https://user-images.githubusercontent.com/87526189/184467905-4fe266e2-0672-4bc2-b9d2-0bbebdf5f1ea.png)  

트랜스포트 계층과 애플리케이션 계층간의 연결되는 문이 있어야 하는데 이것을 소켓이라 한다.

## 프로세스 주소 배정

* host의 IP정보만으로는 궁극적으로 메시지가 전달되어야할 애플리케이션 프로세스를 식별할 수가 없다.

* host를 식별하는 32bit IP와 더불어 **포트(port)** 번호를 사용한다.

  * 포트(port) : host안에서 실행되고 있는 프로세스를 식별해주는 번호

* 포트번호의 예

  * HTTP 서버 프로세스 : 80

  * mail 서버 프로세스 : 25
    * 이러한 포트번호를 well known port number라함

* 결론 : host는 IP번호로 식별, 해당 호스트의 프로세스는 포트 번호로 식별

## 애플리케이션이 필요한 트랜스포트 서비스
* 신뢰적인 데이터 전송(데이터 무결성: data integrity)

  * 몇몇의 (파일전송, 웹)등과 같은 앱들은 100%의 신뢰적인 데이터 전송를 요구한다.

  * 오디오나 비디오 같은 애플리케이션은 어느정도의 데이터 손실을 견딜 수 있다.

* 시간(timing)
  * (인터넷 전화, 게임)등과 같은 앱들은 짧은 전송 딜레이를 요구한다.
  
    * 여기서 딜레이는 source로 부터 destination까지 전송되는데 걸리는 시간이다.

* 처리량(throughput)

  * (오디오, 비디오)등과 같은 multimedia(다중매체) 스트리밍의 경우 단위 시간동안 일정량의 프레임을 전송해야한다.

  * 따라서 처리율의 최적화가 중요함

  * 탄력적 애플리케이션(elastic application)은 가용한 처리율이 많으면 많은 대로 적으면 적은 대로 이용한다.

    * 전자메일, 파일 전송, 웹 전송 등이 있다.

* 보안(security)

## 인터넷 전송 프로토콜이 제공하는 서비스
1. TCP(Transmission Control Protocl) 서비스
   1. 신뢰적인 데이터 전송 서비스
      1. 애플리케이션이 TCP프로토콜에게 데이터 전송을 부탁하면 애플리케이션은 내가 부탁한 데이터는 상대방에게 절대로 오류없이 순서대로 잘 도착할 것이라 확신할 수 있다. 

    2. 연결지향형(connection-oriented) 서비스
       1. TCP 클라이언트와 서버가 서로 핸드셰이킹 과정을 통해 전송 제어 정보를 교환한다.  

       3. 핸드셰이킹 과정이 클라이언트와 서버에 패킷이 곧 도착하니 준비하라고 알려주는 역할을 한다.

       5. 셰이킹 단계를 지나면, TCP연결이 두 프로세스의 소켓 사이에 존재한다고 얘기한다.

    3. 흐름 제어(flow control)
       1. sending TCP에서 너무 빠르게 데이터를 전송하게 되면 receiving TCP 버퍼가 가득 차게되는데 그러면 connection을 통해서 sending TCP에게 속도 조절을 요청하여 속도 조절을 함

    4. 혼잡 제어(congestion control)
       1. sendgin TCP와 receiving TCP 사이에는 네트워크가 있는데 네트워크의 여러 라우터의 홉 사이이의 통신시 라우터의 버퍼가 가득차게 되면 connection을 통해 sending TCP에게 요청하여 속도조절을 하게된다.

2. UDP(User Datagram Protocol) 서비스
   1. 신뢰적이지 않은 데이터 전송 서비스

## 애플리케이션 계층 프로토콜 정의

* 교환하는 메시지 타입을 정의
  * request 메시지, response 메시지

* 메시지의 문법을 정의
  * 메시지 내부의 필드와 필드 간의 구별법

* 메시지의 의미
  * 필드의 의미, 즉 필드에 있는 정보의 의미

* 규칙
  * 언제, 어떻게 프로세스가 메시지를 전송하고 메시지에 응답하는지 결정

### 프로토콜의 종류
* 개방 프로토콜
  * RFC(인터넷 표준)에서 정의하고 있음
  * ex) HTTP, SMTP

* 비개방 프로토콜
  * ex) Skype

<br/>

# 웹과 HTTP
* 웹 페이지(web page)는 객체(object)로 구성된다.

* 객체(object)는 HTML파일, JPEG 이미지, 오디오파일, 자바 애플릿 등이 될 수 있다.

* base HTML 파일이 웹 페이지를 구성하고 있는데 이 웹페이지는 몇몇의 객체를 참조하고 있는 형태이다.

* 각 객체는 URL형태이다.
  * www.someschool.deu/someDept/pic.gif  

    * home name부분 : www.someschool.edu  

    * path name부분 : /someDept/pic.gif

## HTTP란
hypertext transfer protocol의 약자이다.  

* 웹이라는 애플리케이션을 위해서 디자인된 프로토콜이다.

* 클라이언트/서버 구조
  
    * 클라이언트 프로세스 : 브라우져
      * HTTP 프로토콜을 사용하여 요청을 하고 응답을 받은 후 화면에 웹 객체를 출력한다.

    * 서버 프로세스 : 브라우져의 요청을 기다리고 요청이 오면 해당 응답을 반환한다.

* TCP를 사용한다.

  * 클라이언트 측에서 서버에게 TCP 연결을 시도한다.

    * 서버의 IP와 포트번호 80에 연결하기 위해 소켓을 생성한다.

  * 서버가 클라이언트 측의 TCP 연결 요청을 받아들인다.

  * TCP 연결을 통해 메시지를 주고 받는다.

  * TCP 연결이 닫힌다.

* HTTP는 비상태(staeless) 프로토콜이다.

  * 서버가 클라이언트가 보낸 요청을 저장하지 않는다.

    * 즉 유저가 이전에 보낸 요청이 무엇이었는지 서버는 전혀 기억하지 않는다.

## 지속(persistent) 연결과 비지속(non-persistent) 연결
최초의 HTTP는 non-persistent였다.  
non-persistent에 단점 때문에 persistent로 변경되었다.

* 비지속 연결(non-persistent) HTTP
  
  * 서버측에서 객체 하나를 보내주고 나면 바로 TCP 연결을 끊음
  
    * 웹 페이지는 하나의 객체로만 이루어지지 않는다.

  * 객체가 10개라면 웹페이지 1개를 받기 위해 TCP 연결을 10번 해야함 따라서 비효율적이다.

* 지속(persistent) HTTP

  * 한 번 TCP 연결을 맺으면 맺어진 TCP 연결을 통해서 여러 객체를 전달한다.


### 비지속(non-persistent) HTTP: 응답 시간
![image](https://user-images.githubusercontent.com/87526189/184528977-358c470e-0d04-420e-9592-1d22195d02d9.png)
* RTT(round trip time) : 작은 패킷이 클라이언트로부터 서버까지 가고, 다시 클라이언트로 되돌아오는 데 걸리는 시간

* HTTP 응답(response) 시간
  * TCP연결을 만들기 위해서 1RTT가 필요하다.

  * HTTP request를 보내고 첫 번째 바이트의 response를 받기까지 1RTT가 소요된다.

  * reponse의 마지막 바이트까지 전달 되어야 완료되므로 파일전송 시간(file transmission time)이 소요된다.

  * 비지속 HTTP 응답 시간 = 2RTT + 전체 파일 전송시간

response time은 웹 페이지 전체가 전달된 것은 아니다.  

base HTML만 도착한 것이다.  

만약 base HTML 이외에 5가지의 객체를 더 참조하고 있다면 추가적으로 5개의 객체가 다 와야지 웹 페이지 전체가 완성되는 것이다.  

비지속 HTTP의 경우에는 객체 하나를 받고나면 서버가 연결을 닫기 때문에 매 객체마다 TCP 연결을 다시 열어야한다.  

즉 각 객체마다 2RTT가 필요하다.

웹 페이지 하나를 다 받기 까지의 시간은 어떻게 될까?

### 지속(persistent) HTML
* 객체를 하나 내보낸 후에도 TCP 연결을 열어둔체로 놔둔다.

* TCP 연결을 위한 1RTT 소요

* base HTML을 보내기 위해 1RTT 소요

* 나머지 보내야할 객체를 한 번에 보내서 1RTT가 소요된다.

## HTTP 메시지 포맷
HTTP는 2종류의 메시지를 사용한다.  

### 1. 요청(requeset) 메시지
1. ASCII 코드로 표현되어 있다.
   
2. 구조

    ![image](https://user-images.githubusercontent.com/87526189/184542496-22bad173-e86b-41bf-bec3-53044c45ec7d.png)  

    * 요청라인(request line)

      * 방식 : 서버에게 어떤작업을 해달라 요청하는 곳

        * GET, POST, PUT ...

      * URL : 요청하는 파일의 URL

      * 버전 : 클라이언트가 사용하는 HTTP 버전

    * 헤더라인(header line)

      * 헤더필드 이름

        * ex) host

      * 값 

        * ex) 그 host의 이름

    * 공백라인

    * 개체몸체(entity body)

#### 서버에게 input값을 보내고 해당 input값에 대한 response를 받는 경우
    1. POST 메서드 : 개체몸체(entity body)에 input값을 담아서 보낸다. 

    2. URL 메서드 : URL에 "?_?_" 이런식으로 물음표 뒤에 담아서 input값을 보낸다.

#### 메서드 타입
1. HTTP/1.0
   1. GET : URL에 해당하는 페이지를 요청할 경우 사용

   3. POST : 입력값을 제공했을 때 그것을 반영하여 웹 페이지를 요청할 때

   5. HEAD : 서버에게 지금 요청한 URL에 해당하는 파일을 보내진 않아도 된다라는 의미 

      1. 즉 서버가 응답 메시지는 보내되 실제 요청한 객체(object)는 싣지 말고 보내라는 것이다.

      3. 개발하는 과정에서 테스트 목적으로 요청을 보내고 응답을 받아보려고 할 때 이것을 사용한다.

2. HTTP/1.1
   1. GET.POST,HEAD
   2. PUT : 클라이언트가 서버의 어떠한 URL에 파일을 업로드를 하는 것이다.
      1. 
   3. DELETE : URL field에 해당하는 파일에다가 delete하라고 서버에게 요청하는 것

### 2. 응답(response) 메시지
![image](https://user-images.githubusercontent.com/87526189/184549011-cb2d7271-8135-46e8-99fd-61cb33eee192.png)  

 상태라인(dtatus line)

  * 버전(version) : 서버의 HTTP 버전이 있다.

  * 상태코드(status code) : ex) 200, 400, 404...

  * 상태구문(status phrase) : ex) ok

* 해더라인(header line)

  * 헤더필드 : date, server, Last_Modified, connection ...

    * Date : 응답을 제공하는 시각

    * server : 서버의 종류

      * ex) Apache

    * Last_Modified : 서버가 제공하는 웹페이지가 마지막으로 수정된 시각

    * connection : ex) keep-Alive-> 객체를 보낸 다음에도 TCP를 닫지 않고 오픈한 상태로 있겠다는 의미

    * content-Length : 보내는 내용의길이가 몇 바이트인지

    * content-Type : 내용의 타입

      * ex) text/html

  * 값

* 공백라인

* 개체몸체 : 요청된 데이터를 body에 담음
  * ex) HTML 파일

#### HTTP 응답 상태코드
* 200 : 응답 메시지의 body에 가보면 요청된 객체가 실려있다는 의미
  
* 301 : 요청된 객체가 다른곳으로 옮겨져 저장되어 있다는 의미

* 400 : 요청 메시지가 잘못돼서 해석할 수 없다는 의미

* 404 : 요청된 웹 페이지가 웹서버에 없다는 의미

* 505 : 클라이언트의 HTTP 버전을 서버가 지원할 수 없다는 의미

## 사용자와 서버 간의 상호작용 : 쿠키(cookie)
앞서서 HTTP서버는 상태를 유지하지 않는다고 했다.  

하지만 웹 사이트가 사용자를 확인하는 것이 바람직할 때가 있다.  

이 목적으로 HTTP는 쿠키(cookie)를 사용한다.  

### 쿠키 기술의 4가지 요소
1. 서버측에서 HTTP 응답 메시지에 쿠키 헤더 라인을 집어 넣어서 보내줘야 한다.

2. 클라이언트측에서 요청을 보낼때도 쿠키 헤더라인을 포함시켜서 보내게 된다.

3. 브라우저(클라이언트)쪽에서는 쿠키 파일을 유지한다.

4. 서버측에서는 벡엔드 데이터베이스를 유지한다.

![image](https://user-images.githubusercontent.com/87526189/184567345-ba866635-360c-4e7d-aa41-6c104fd628f1.png)

### 쿠키를 통해 할 수 있는 일
* 인증

  * 매번 웹 사이트에 페이지를 요구할 때마다 인증을 새로해야하는 번거로움을 피할 수 있다.

* 쇼핑몰의 주문 담기

* 사용자의 세션(session)을 유지시켜 준다.(웹 메일)

  * 세션(session) : 컴퓨터 프로세서들 사이에서, 서로를 인식한 후에 데이터 송수신을 마칠 때까지의 기간.

## 웹 캐싱(chache) / (proxy server)
웹 캐시의 목적 : 캐시를 로컬 사이드 내에 둠으로써 오리지널 서버까지 가지 않고도 객체를 가져올 수 있게 하기 위함

* 캐시를 두는 경우 사용자의 브라우저는 언제나 캐시를 통해서 웹 접근을 하도록 설정을 해둔다. 
* 브라우저는 HTTP 요청을 캐시로 보내게 된다.
  * 객체가 캐시에 있는 경우 : 캐시로부터 객체를 반환 받음
  * 객체가 캐시에 없는 경우 : 객체 요청을 오리지널 서버에 요청을 하고 객체를 반환 받는다.

* 캐시는 서버도 되고 클라이언트도 된다.  

* 일반적으로 캐시는 대학교, 회사 등의 ISP에 의해서 설치된다.

### 왜 웹 캐싱을 사용할까?
* 클라이언트 요청에대한 응답시간을 단축시킬 수 있다.

* 해당 기관의 접근링크(access link) 트래픽 양을 줄일 수 있다.

* 자금이 넉넉치 않은 컨텐츠 제공자에게 비용을 절감시켜줄 수 있다.

### 조건부 GET
웹 캐싱이 사용자가 느끼는 응답 시간을 줄일 수 있지만 캐시 내부에 있는 객체의 복사본이 새것이 아닐 수 있다는 문제가 발생한다.  

즉 복사본이 클라이언트에 캐시된 이후에 웹 서버에 있는 객체가 갱신되었을 수 도 있다는 것이다.  

이때 HTTP는 모든객체들이 최신의 것임을 확인하면서 캐싱하는 방식을 **조건부 GET**이라고 한다.  

#### 조건부 GET 메시지 조건
1. GET 방식을 사용한다.

2. If-Modified-Since 헤더라인을 포함하고 있다.

#### 조건부 GET의 동작방식
1. 브라우저의 요청을 대신해 프록시 캐시는 요청 메시지를 웹 서버로 보낸다.

2. 웹 서버는 캐시에게 객체를 가진 응답 메시지를 보낸다.

3. 일주일 후에 다른 브라우저가 같은 객체를 캐시에게 요청하면 객체는 여전히 저장되어 있다. 이 객체는 지난주에 웹 서버에서 수정되었으므로 브라우저는 조건부 GET으로 갱신 조사를 수행한다.
   1. If-modified-since: 헤더 라인의 값이 이줄일 전에서버가 보낸 Last-Modified 헤더라인의 값과 저확히 일치하는 경우 body가 비어있는 응답을 반환한다.

4. 응답 메시지는 304 Not Modified상태 라인을 갖고 있고 이것은 클라이언트에게 요청 객체의 캐시된 복사본을 사용하라는 것을 의미한다.

<br/>

# 인터넷 전자메일

* 사용자 에이전트(User Agent)
  * 메일 메시지를 작성하고 편집하고 읽게 해주는 프로그램이다.
  * ex) Outlook, 아이폰 mail client, Gmail 등이 있다.

* 메일 서버(Mail Server)

  * 상대방에게 보내려고 작성한 메일이나 수신된 이메일 메시지를 메일 서버가 받는다.

  * 메일 서버는 2가지의 데이터 구조를 가진다.

    1. 메일박스 : 수신된 메일들을 담아두는 장소

       1. 사용자 구분을 하여 사용자별로 메일박스가 존재한다

    2. 메시지 큐(message queue) : 송신하는 메시지를 담고 있다.

       1. 사용자 구분을 따로 하지 않는다.

* 메일 프로토콜(Mail Protocol)

  * simple mail transfer protoco(SMTP) 라고 부른다.

  * 메일을 읽을때는 POP3, IMAP, HTTP 프로토콜을 이용하여 메일을 읽는다.

  * 메일의 시스템구성

    <img width="1084" alt="image" src="https://user-images.githubusercontent.com/87526189/184831178-019ff44c-ee66-470d-b1a1-5bef79728a69.png">  

    1. 이메일을 작성하면 사용자 에이전트가 송신측 메일 서버로 메시지를 보낸다.

       1. 그때 사용되는 프로토콜이 SMTP이다.

    2. 송신측 메일 서버로부터 수신측 메일 서버로 전달된다.

       1. 마찬가지로 SMTP릁 통해 보내진다.

    3. 수신측 메일 서버에 메시지가 들어오면 수신측 사용자 에이전트가 mail접근 프로토콜(POP,IMAP, HTTP..)등을 통해서 메시지를 읽어들인다

## SMTP

### SMTP 프로토콜
* 사용자 에이전트가 메일을 메일 서버측으로 송신하면

  * 클라이언트 : 유저 에이전트

  * 서버 : 메일 서버

* 메일 서버가 수신측 메일서버로 송신하면

  * 클라이언트 : 송신측 메일 서버

  * 서버 : 수신측 메일 서버

* TCP 위에서 동작한다.

* SMTP 서버 프로세스는 포트번호 25번을 사용한다.

* SMTP의 대략적인 전송 3단계

  1. 핸드셰이킹(greeting) 단계

  2. 메시지 전송 단계

  3. 종료 단계

* 클라이언트는 명령어(command)가 들어가있고 서버의 메시지에는 응답(response)이 들어가있다.(HTTP,FTP와 유사)

  * 명령어(command) : ASCII 텍스트로 구성

  * 응답(response) : 상태코드와 구문

* 이메일 메시지는 반드시 ASCII 텍스트 메시지로 구성되어야 한다.

### SMTP 상호작용
    s: 220 hamburger.edu                                     //나는 hamburger.edu이야 //greeting 단계 시작
    c: HELO crepes.fr                                        //안녕 나는 crepes.fr이야
    s: 250 Hello crepes.fr, pleased to meet you              //crepes.fr안녕 만나서 반가워 //여기까지가 핸드셰이킹 greeting 단계가 완료
    c: MAIL FROM: <alice@crepes.fr>                          //alice@crepes.fr에서 메일을 보냈어 //메시지 전송 단계 시작
    S: 250 alice@crepes.fr... Sender ok                      //OK 대답해준다.
    c: RCPT TO: <bob@hamburger.edu>                          //RCPT : Recipient 받는사람을 의미 -> 수신자가 누구인지 명시
    s: 250 bob@hamburger.edu ... Recipient ok                //수신자 확인 완료
    C: DATA                                                  //이제 데이터를 보낸다는 신호
    S: 354 Enter mail, end with "." on a line by iterself    //메시지의 끝은 "."로 표시를 해달라고 요청
    C: Do you like ketchup?                                  //사용자가 쓴 메시지1
    C: How about pickles?                                    //사용자가 쓴 메시지2
    C: .                                                     //메시지의 끝을 알림 //메시지 전송단계 끝
    S: 250 Message accepted for delivery                     //여기까지가 메시지 전송 단계 완료 //종료 단계 시작
    C: QUIT                                                  //메시지를 다 보냄
    S: 221 hamburger.edu closing connection                  //연결을 닫음 //종료 단계 끝

### SMTP 와 HTTP의 차이점
* HTTP : pull
* SMTP : push

* 둘 다 ASCII로 된 명령/응답을 한다.

* HTTP : 하나의 응답에 하나의 객체를 실는다. 

* SMTP : 한 번 greeting 후에 한 메일에 여러 파일들로 구성됐을 때도 한꺼번에 다 실을 수 있다.  

<br/>

---
# 3주차

## 메일 접속 프로토콜(mail access protocol)
![image](https://user-images.githubusercontent.com/87526189/185573484-59deb2df-4447-40d9-b985-2afcbec98b92.png)

push : 송신측 사용자 에이전트A -> 전송 메일 서버 -> 수신 메일 서버 과정을 거친다.  

pull : 수신 매일 서버 -> 수신측 사용자 에이전트B

### 메일 접속 프로토콜의 종류
* POP : Post Office Protocol[RFC 1939]의 약자이며 가장 단순한 프로토콜

* IMAP : Internet Mail Access Protocol[RFC 1730]의 약자이고 POP의 단점을 보완한 매우 복잡한 프로토콜

* HTTP : 수신측 메일 서버가 웹메일인 경우 HTTP 프로토콜을 이용해서 웹 메일을 가져오기도 한다.

### POP3 프로토콜
<img width="320" src="https://user-images.githubusercontent.com/87526189/185606257-9ebf3841-a2e4-4519-9b41-5e047e0b378c.png">  

#### POP3프로토콜의 진행과정

* 인증단계(authorization phase)
  * 클라인언트는 명령을 내림
    * user : 사용자 이름
    * pass : 비밀번호

  * 서버는 응답을 함
    * +OK
    * -ERR

* 트랜잭션 단계(tracsaction phase)
  * list : 메시지 번호와 바이트 사이즈를 반환 하고 .이 오면 메시지의 끝임을 표시한다.
  * retr : 번호를 사용하여 메시지를 검색한다.
  * dele : 번호를 통하여 삭제를 한다.
  * quit : 서버에게 통신을 끊기를 요청
  
<br/>

#### POP3는 2가지의 모드가 있다.
* 다운로드 후 삭제모드

  * retr후 dele를 수행

  * ex) 회사에서 메일 3개를 읽어오면 집에 돌아가고나서는 회사에서받은 메일 3개를 제외하고 새롭게 도착한 메일만 읽을 수 있다.

* 다운로드 후 유치모드

  * 다운로드 후 삭제모드와 다르게 retr후 dele를 수행하지 않고 list파악 후 차례대로 list에 있는 모든 메시지들을 retr하고 quit하게 된다. 

  * ex) 메일 메시지들이 메일 박스에 그대로 유지되어서 다른 곳에서 읽어도 아까 읽었던 메시지가 다시 그대로 새 메시지인 것 처럼 (retreive)되찾아올 수 있다.

* POP3는 세션의 상태를 유지하지 않기 때문에 지난번 세션에서 이 사용자가 어떤 메시지를 retreive를 했는지 서버는 전혀 기억을 하고 있지 않는다.

### IMAP
POP3의 다운로드 후 삭제모드와 다운로드 후 유치모드 둘 다 불편한 부분이 존재하여 만들어진 프로토콜이 IMAP이다.  

메일 서버의 박스에다가 사용자가 하는 일 모두 반영한다.
즉 서버의 메일박스에다가 작업을 하게 되는 것이다.

* 모든 메시지들이 서버에 유지가된다.

* 서버의 메일박스에다가 폴더를 생성할 수 있다.

* 한 세션에서 작업한 것(특정 메시지를 다른 폴더로 옮기거나 메시지를 삭제하는 등등)을 다음 세션을 열었을 때 그대로 메일박스에 이미지가 그대로 유지되고 있다.

# DNS(Domain Name System) 인터넷 디렉터리 서비스
인터넷 호스트를 식별하는 방법에는 2가지가 있다.
1. 사람이 인터넷 호스트를 식별하는 방식인 호스트 네임(hostname)
   1. ex) www.facebook.com

2. 라우터가 식별하기 편한 방식인 IP주소(32bit)
   1. ex) 121.7.106.83

DNS는 호스트 네임과 IP주소를 매핑해주는 역할을 한다.

### Domain Name System
* 광범위한 데이터베이스를 사용한다.

  * 많은 damin name server의 계층속에서 분산되어 수행되는 분산데이터베이스이다.

* 애플리케이션 계층 프로토콜이다.

  * 모든 애플리케이션은 호스트네임->IP주소로 매핑하는 과정을 거치게 되므로 네트워크 계층 프로토콜로 처리해주는 것이 옳다고 생각할 수 있다. 하지만 네트워크 계층은 가장 심플한 패킷을 전달해주는 일만 수행하도록 만들기 위해서 즉 모든 복잡한 일은 edge로 몰아내기 위해서 애플리케이션으로 처리하도록 구현했다.

## DNS가 제공하는 서비스와 구조
### DNS 서비스
* 호스트네임을 IP주소로 변경하는 서비스를 제공한다.

* 호스트 엘리어싱(host aliasing)(별칭) 서비스

  * alias name을 정식 호스트 네임(canonical hostname)으로 변환해주는 서비스를 제공한다.

* 메일 서버 엘리어싱(mail server aliasing)

  * DNS는 제공된 별칭 호스트 네임에 대한 정식 호스트 네임을 얻기 위해 메일 애플리케이션에 의해 수행된다.

* 부하 분산(load distribution)

  1. 인기 있는 사이트는 여러 서버에 중복되어 있어 각 서버가 다른 종단 시스템에서 수행되고 다른 IP주소를 갖는다.  

  2. DNS 데이터베이스는 이 IP 주소 집합을 가지고 있다.

  3. 클라이언트가 주소 집합으로 매핑하는 호스트 네임에 대한 DNS 질의를 하면, 서버는 IP 주소 집합 전체를 가지고 응답하여 주소를 순환식으로 보낸다.

  4. 따라서 트래픽을 분산하는 효과를 가진다.


## 분산 계층 데이터베이스
DNS 서버는 서버 사이에 분산된 세 유형의 DNS 서버가 있다.  

1. 루트(root) DNS 서버

3. 최상위 레벨 도메인 네임(TLD, top-level domain)DNS 서버

5. 책임(authoritative) DNS서버

### 분산 계층 데이터베이스 동작원리
![image](https://user-images.githubusercontent.com/87526189/185639886-fb7e9f75-41e6-4a9a-a3c5-e2ea8a4a4726.png)  
DNS 클라이언트가 호스트 네임 www.amazon.com의 IP주소를 결정하기 원한다고 가정한다.  

1. 클라이언트는 루트 서버 중 하나에 접속한다.

2. 루트 서버는 최상위 레벨 도메인 com을 갖는 TLD서버 IP주소를 보낸다.
  
3. 클라이언트는 이 TLD 서버 중 하나에 접속한다.
   
4. 서버는 도메인 amazon.com을 가진 책임 서버의 IP 주소를 보낸다.

## 로컬 DNS 서버
* 위의 계층구조에 엄격하게 속하지 않는다.

* 대학이나 주거지역 ISP와 같은 ISP들은 로컬 DNS 서버를 가진다.

* 호스트가 DNS 쿼리를 만들어내면 쿼리는 로컬 DNS 서버로 보내진다.

  * 로컬 DNS 서버가 쿼리에 대한 매핑정보를 캐싱하고 있다면 그것으로 응답함

  * 없다면 계층 DNS 시스템으로 쿼리를 던진다.

### 최상위 레벨 도메인 네임(TLD), 책임(authoritative) 서버
* top-level domain(TLD) 서버

  * com, org, net, edu, aero, jobs 등과 같은 도메인을 각각 담당한다.

  * uk, fr, ca, jp ,kr 등과 같은 국가 domain server를 TLD에서 담당한다.

  * TLD를 관리하는 기관이 존재하는데 .com같은 경우 Network Solutions라는 기관이 관리한다.

  * .edu TLD는 Educause for이라는 기관이 관리한다.

  * .kr을 관리하는 기관은 한국인터넷정보센터이다.

* authoritative DNS 서버

  * 조직 자신의 DNS 서버를 의미한다.

  * TLD에 의해 관리되어지는 DNS 서버이다.

  * 조직에 속해있는 호스트네임을 IP와 매핑해준다.

### 루트 네임 서버
* TLD 서버를 관리하는 서버이다.

* 로컬 DNS 서버가 host name에 대한 정보를 가지고 있지 않을 때 제일 먼저 컨택하는 서버이다.

### DNS 서버의 상호작용
* 반복적 질의(iterative query)

  * 질의를 받은 서버가 자기가 매핑정보 자체는 제공하지 않고 누구를 컨택해야할 지만 알려줌  
  <img width=300 src="https://user-images.githubusercontent.com/87526189/185649023-65df9f80-25f9-431e-b237-0cdc24102efb.png">

* 재귀적 질의(recursive query)

  * 서버가 질의를 받으면 어떻게 해서든 자기가 그 매핑정보를 구해서 질의한 호스트에게 답을 해준다.  
  <img width=300 src="https://user-images.githubusercontent.com/87526189/185649607-fb578846-d630-4c79-9b6f-4a6905274be8.png">

## DNS 캐싱
* 일반적으로 로컬 네임 서버는 TLD 서버를 캐싱하고 있다.

* 유효 기간이 지난 정보로 답을 할 수 있다는 문제를 가지고 있다.

  * 매핑정보에는 항상 TTL(Time to leave)정보를 가진다.

    * TTL 시간동안만 유지하고 시간이 지나면 버린다.

* IETF 표준에서는 어떠한 로컬 사이트에서 name에서 IP로의 매핑이 변경 됐다면 세상에 업데이트하고 알리는 메커니즘이 제안되었다.

### DNS 프로토콜 메시지 포맷
![image](https://user-images.githubusercontent.com/87526189/185653428-b622fc76-186f-43b4-8d81-c1a32a6dced7.png)  
* 메시지의 종류는 요청(query)과 응답(reply) 2개이다.

  * 요청과 응답 메시지는 같은 포맷을 사용한다.

#### 메시지 헤더
* 식별자(identification) : 요청과 응답은 같은 식별자를 사용하여 짝을 이룬다.

* 플래그(flag) : 

  * 요청인지 응답인지 나타냄

  * 재귀적으로 처리하길 희망하는지 나타냄

  * 서버의 경우 재귀적으로 처리할 수 있음을 나타냄

  * 응답에 실려있는 정보가 책임(authoritative) 서버일 경우 응답 메시지에 설정된다.

#### 메시지 필드
헤더에 4개의 "개수" 필드가 있다.  

* 질문 영역 : 현재 질의에 대한 정보를 포함한다.

  * 질의되는 이름을 포함하는 이름필드

  * 이름에 대해 문의되는 질문 타입을 나타내는 타입 필드

* 답변 영역 : 원래 질의된 이름에 대한 자원 레코드를 포함한다.

## DNS 레코드
* DNS : 분산 데이터베이스 저장공간에 자원 레코드를 가지고 있다.  

* 자원 레코드(resource recodrd)(RR) : 데이터베이스에 저장하는 정보

* RR 포맷 : name, value, type, ttl

  * type=A

    * name : 호스트 네임

    * value : IP 주소

  * type=CNAME

    * name : 별칭(alias)

    * value : 정식 호스트 네임(canonical hostname) 

    * ex)www.ibm.com 의 실제 이름은 servereast.backup2.ibm.com

  * type=NS

    * name : 도메인 네임

    * value : 이 도메인을 담당하는 네임 서버

  * type=MX

    * name : 도메인 네임

    * value : 메일 서버

### 각 DNS 서버에서 RR에 저장되는 것
* 루트 DNS 서버 : 각 top level domain(TLD)에 대해서 그 도메인을 담당하는 TLD DNS 서버가 누구인지 저장하고 있다.
  * .com을 담당하는 TLD서버 이름
  * .edu를 담당하는 TLD서버 이름

* TLD DNS 서버 : .com 담당하는 TLD 서버라면 .com안에 있는 모든 기관을 담당하는 authoritative DNS 서버의 이름이 뭔지 저장하고 있다.

* authoritative(책임) DNS 서버 :  자기 기관 내에 속해있는 모든 호스트에 대해서 호스트네임-IP 매핑정보를 가지고 있다.

<br/>

# P2P 애플리케이션
## 순수한 P2P 구조
* 항샹 켜져있는 서버를 사용하지 않는다.
* 임의의 end system들이 직접 통신한다.
* 이때 이 end system(종단시스템)을 peer라고 부른다.
* Peer는 네트워크에 연결됐다가 끊어졌다가 하고 이때 IP주소가 간간이 변경된다.

### P2P구조 애플리케이션
* 파일 분배 시스템(비트토렌트)
* VoIP(Skype)
* 스트리밍 시스템(KanKan)
 
파일을 원하는 클라이언트가 늘어나면 그와 더불어 파일을 업로드 할 수 있는 능력도 늘어나기 때문에 결국 원하는 클라이언트 수에 비례해서 파일 업로드 시간이 늘어나지 않는다.  

따라서 확장성이 좋다.  

### 비트토렌트(BitTorrent)
파일 분배를 위한 인기 있는 P2P프로토콜이다.  

* 파일을 256Kb 덩어리로 나눈다.

* 토렌트 속 peer들은 파일 덩어리를 주고 받는다.

  * 토렌트(torrent) : 파일의 덩어리를 교환하는 사용자의 그룹이다.

  * 트랙커(tracker) : 각 토렌트에 속하는 peer들이 누구인지 추적한다.

  * 청크(chunk) : 파일 덩어리

#### 비트토렌트:동작예시
![image](https://user-images.githubusercontent.com/87526189/185772089-6608ebeb-a270-4e62-b821-8acf83e1046b.png)  
1. 사용자는 트랙커를 먼저 컨택하여 트랙커로부터 현재 자기가 원하는 파일에 해당하는 토렌트에 속하는 peer들이 누가 있는지 리스트를 받는다.

3. 리스트에 있는 Peer들로부터 청크(chunk)를 공급받는다.

   1. 청크를 가지고 있지 않지만 시간이 지나면서 다른 peer에게 청크가 누적된다.

5. 다운로드 하는동안 peer는 다른 peer들을 위해 청크를 업로드한다.

7. peer가 청크를 교환하는 peer를 변경할 수 있다.

9. churn : 피어가 없어지기도 하고 새로 들어오기도 하는데 이러한 피어의 변화를 말한다.

   1. churn이 P2P시스템에서 문제가 된다.

11. 어느 한 peer가 파일 전체를 가지면 이기적이게 떠나거나 이타적으로 토렌트에 남을 수 있다.

#### 비트토렌트: 파일 청크의 요청, 응답
* 요청 청크 :

  * peer는 정기적으로 이웃peer에게 청크 리스트를 요청한다.

  * peer는 요청에서 누락된 청크를, rarest first로 받는다.

    * rarest first : 이웃들 중 가장 적은 반복 복사본을 가진 청크

* 응답 청크: TFT(tit-for-tat)

  * TFT(tit-for-tat) : 자신에게 잘 공급해주는 peer에게 자신도 잘 공급해주는 것

    * 이기적인 peer가 살아남지 못하게 하는 시스템이다.

  * 각 peer는 10초마다 나에게 공급을 잘해주는 top 4 peer를 선정한다.

    * 그 top 4 peer에게 자신도 열심히 제공을 해준다.

  * 매 30초마다 무작위로 아무 peer나 선책하고, 청크를 보내본다.

    * 그러다 top 4 peer로 선정된다면 새롭게 peer가 변경된다.

    * 그러면 peer는 더 좋은 파트너를 구할 수 있게 된다.

<br/>

# 소켓 프로그래밍
소켓 : 프로그래머가 작성하는 애플리케이션 프로그램과 운영체제가 컨트롤하는 트랜스포트 계층 사이의 인터페이스이다.  

### 2개의 트랜스포트 서비스를위한 2개의 소켓 타입
1. UDP : 비연결형 서비스이고 독립적인 데이터 패킷을 보냄, 전송에 대해 보장하지 않음(비신뢰적)
2. TCP : 연결지향형 서비스이고 신뢰적 바이트 스트림 채널을 제공

## UDP를 이용한 소켓 프로그래밍

### UDP: 서버와 클라이언트 사이에 연결이 없다.
* 데이터를 보내기 전 handshaking이 없다.
* 각 데이터 마다 IP 목적지 주소와 포트번호를 붙여서 보낸다.
* 서버는 클라이언트로부터 받은 세그먼트(segment)로부터 IP주소와 포트번호를 추출한다.

## TCP 소켓 프로그래밍

### 클라이언트는 반드시 서버에 연결해야한다.
* 서버 프로세스는 반드시 처음 실행중이여야 한다.
* 서버는 클라이언트의 연결을 받아들이는 용도의 소켓을 생성해야한다.

### 클라이언트는 아래의 것들에 의해 서버에 연결되어야한다.
* handshaking을 위해서 클라이언트가 컨택할 서버의 IP주소 지정, 포트번호 지정 및 소켓 생성을 한다.
* 클라이언트의 소켓을 생성하면서 클라이언트쪽 TCP가 서버쪽 TCP하고 연결된다.
* 클라이언트와 접촉할 때, 서버 TCP는 서버 프로세스가 특정 클라이언트와 통신하기 위한 새로운 소켓을 만든다.
  * 서버가 여러 클라이언트와 대화할 수 있도록 허용한다.
  * source의 포트번호는 클라이언트를 구별하기 위해 사용된다.

TCP는 클라이언트와 서버 간에 신뢰할 수 있는 순차 바이트 스트림전송 ("파이프")를 제공한다.

<br/>

---
# 4주차

# 트랜스포트 계층 서비스 및 프로토콜
* 트랜스포트 계층 프로토콜은 서로 다른 호스트에서 동작하는 애플리케이션 프로 세스들 간의 논리적 통신(logical communication)을 제공한다
* 트랜스포트 프로토콜은 종단 시스템(end system)에서 동작한다.
  * 송신측 : 앱 메시지를 세그먼트로 분할하고 네트워크 계층으로 전달한다.
  * 수신측 : 세그먼트를 메시지로 재구성하고 애플리케이션 계층으로 전달합니다.

* 앱에서는 2개의 트랜스포트 프로토콜을 사용할 수 있다.
  * 인터넷 : TCP 와 UDP

## 트랜스포트 VS 네트워크 계층
* 네트워크 계층 : 호스트 사이에서의 논리적 통신(logical communication)을 한다.

* 트랜스포트 계층 : 목적지 호스트로 도착한 메시지를 목적지 프로세스로 전달하는 역할을 수행한다.
  * 네트워크 계층 서비스에 의존, 강화한다.

## 인터넷의 프랜스포트 계층 프로토콜
* TCP는 신뢰적이고 순차적인 전송을 한다.
  * 혼잡제어(congestion control)
    * 네트워크에서의 오버헤드 관리

  * 흐름제어(flow control)
    * 수신측 버퍼의 오버헤드 관리
  * 연결설정(connection setup)

* UDP는 신뢰적이지 않고 비순차적인 전송
  * 네트워크 계층의 IP에서 최고의 성능을 위해 확장성이 필요없다

* TCP UDP 둘 다 사용할 수 없는 서비스
  * 지연을 보장하는 서비스
  * 대역폭을 보장해주는 서비스

# 다중화(Multiplexing)와 역다중화(demultiplexing)
<img width="666" alt="image" src="https://user-images.githubusercontent.com/87526189/186854850-79339ade-895c-44f9-886b-a448444e4fad.png">  

## 다중화(Multiplexing)
클라이언트 호스트에 있는 여러개의 호스트 모두가 트랜스포트 계층으로 각자의 소켓을 통해서 메시지 전송을 요청할 것이다.  

트랜스포트 계층에서의 입장에서 살펴보면 UDP의 경우 UDP를 사용하는 여러 프로세스가 동시에 메시지 전송을 부탁하면 다중화(Multiplexing)하여 메시지를 전송하게 된다.  

위와같이 전송하게되면 내려보내지는 메시지마다 목적지가 어디인지 기록하여 한 길로 네트워크 계층으로 내보내게 된다. 

따라서 송신측에서는 Multiplexing이 일어난다.

## 역다중화(Demultiplexing)
각각의 다른 호스트들의 클라이언트 프로세스들로부터 메시지를 받을 것이다.  
그런데 그 메시지들이 전부 네트워크 계층을 통해서 트랜스포트 계층으로 한 줄로 올 것이다.  
트랜스포트 계층으로 한 줄로 올라온 메시지들을 목적지 애플리케이션 프로세스로 배달해줘야 한다.  
즉 Demultiplexing이 일어나야 한다.  

송시측에서 multiplexing할 때 찍어뒀던 목적지 정보를 이용해서 수신측에서는 Demultiplexing을 하게 되는 것이다.

### 역다중화는 어떻게 동작할까
<img width="242" alt="image" src="https://user-images.githubusercontent.com/87526189/186874492-b36a3001-ff92-4748-84bf-1ba51354f02f.png">  
위 사진은 TCP와 UDP의 세그먼트 포맷이다.  

* 호스트가 IP 데이터그램을 수신한다.
  * 각각의 데이터그램은 출발 IP 주소와 도착 IP 주소를 가진다.

  * 각 데이터그램은 트랜스포트 계층 세그먼트를 하나 전송한다.
  * 각 세그먼트는 출발지 포트번호와 도착지 포트번호를 가진다.

* 호스트는 IP 주소 및 포트 번호를 사용하여 세그먼트를 적절한 소켓으로 전송합니다.

## 결론
송신측에서는 Multiplexing을 수행하게되고,  

수신측에서는 Demultiplexing을 수행한다.

## 비연결형 다중화와 역다중화
* 호스트가 UDP 세그먼트를 받으면
  * 세그먼트에서 목적지 포트번호를 확인한다.
  * 포트번호에 해당하는 소켓으로 UDP 세그먼트를 전달한다.

## 연결형지향형 연결형 다중화와 역다중화
* 4-type으로 식별되는 TCP 소켓:
  * 출발 IP 주소
  * 출발 포트 번호
  * 목적지 IP 주소
  * 목적지 포트 번호

* demux: 수신기는 네 가지 값을 모두 사용하여 세그먼트를 적절한 소켓으로 유도한다.

* 서버 호스트는 많은 동시 TCP 소켓을 지원할 수 있다.
  * 각 소켓을 식별된다. 

* 웹 서버는 각 연결 클라이언트에 대해 서로 다른 소켓을 가지고 있다.
  * non-persistent HTTP는 각 요청에 대해 서로 다른 소켓을 가진다.

# UDP: User Datagram Protocol
* 비연결형 트랜스포트를 수행한다.
  * 즉 헨드셰이킹이 없다.

  * 각 세그먼트를 독립적이게 UDP 세그먼트를 주고 받는다.

* 네트워크 계층에서 호스트 전송을 제공해주는 서비스에 추가적인 다른 서비스를 전혀 하지 않는다. 
* "best effort" 서비스를 제공한다.
  * 네트워크가 어떤 세그먼트를 배달해주면 그 세그먼트를 그냥 애플리케이션에 배달하는 것이다. 

  * 데이터를 잃을 수 있다.
  * 데이터가 순서에 어긋나게 애플리케이션에 배달될 수 도 있다.

* UDP의 사용
  * 스트리밍 멀티미디어 앱(손실에 관대함, 처리량에 민감함)

  * DNS
  * SNMP : 네트워크 관리 프로토콜

* 데이터의 무결성 매우 중요한 애플리케이션인 경우 UDP를 사용하는 경우도 있다.
  * 애플리케이션 스스로가 무결성을 체크한다

  * 에러가 발생했을 때 회복할 수 있는 방법을 보유하고 있다.

## UDP 세그먼트의 구조
<img width="242" alt="image" src="https://user-images.githubusercontent.com/87526189/186887492-3102f05d-7473-42a5-815f-ca14600713a1.png">

## UDP의 장점
* 연결 설정을 하지 않기 때문에 딜레이가 짧다.

* 연결이 없기 때문에 간단하다 
* UDP 세그먼트의 헤더 사이즈가 작다
* 혼잡(congestion) 제어가 없기 때문에 애플리케이션이 데이터 생성하는 속도로 네트워크에 데이터를 밀어 넣을 수 있다.

## UDP 체크섬
목표 : 세그먼트 전송시 에러를 감지한다.

* 송신측
  * UDP는 세 그먼트 안에 있는 모든 16비트 워드 단위로 더한다.

  * 이에 대하여 다시 1의 보수를 수행 한다.
  * 덧셈 과정에서 발생하는 오버플로는 “윤회식 자리올림(wrap around)”한다.
  * 이 결과값이 UDP 세그먼트의 체크섬 필드에 삽입된다

* 수신측
  * 수신한 세그먼트의 체크섬을 계산한다.

  * 만약 계산된 체크섬이 체크섬 필드의 값과 같다면
    * YES : 에러가 감지되지 않는다.

    * NO : 에러로 감지됨

# TCP: transmission control protocol
## TCP의 개요
* point-to-point
  
  * 송신측도 하나 수신측도 하나이다.
* 신뢰적이고 순차적인 바이트 스트림
* 파이프라인
  * TCP의 혼잡과 흐름 제어를 윈도우 크기로 설정한다.
* 양방향 데이터 통신
  * 
* 연결지향형
  * 데이터 교환전 핸드셰이킹을 통해 송신측과 수신측의 상태를 초기화 한다.
* 흐름제어
  * 전송자는 수신자가 데이터가 쌓이지않도록 제어한다.
* 혼잡제어
  * 전송자는 네트워크에 데이터가 쌓이지 않도록 제어한다.

## TCP 세그먼트의 구조
<img width="500" alt="image" src="https://user-images.githubusercontent.com/87526189/186901400-1ec014f7-f092-4f9f-a200-b48464d722d3.png">  

* 출발지(source) 포트번호 필드 : 다중화 및 역 다중화를 하는 데 사용된다.
* 목적지(destination) 포트 번호 필드 : 다중화 및 역 다중화를 하는 데 사용된다.
* 순서번호 필드(sequence number field)
* 확인응답번호 필드(acknowledgement number field)
* 수신윈도우 (receive window) 필드 : 16비트이며 흐름제어에 사용되고 수신자가 받아들이려는 바이트의 크기를 나타내는 데 사용된다.
* 헤더길이(header length) 필드 : 4비트이며 32비트 워드 단위로 TCP 헤더의 길이를 나타낸다. 그리고 TCP헤더는 TCP옵션(option) 필드 때문에 가변적인 길이가 될 수 있다.
* 옵션(option) 필드 : 송신자와 수신자가 최대 세그먼트 크기(MSS)를 협상하거나 고속 네트워크에서 사용하기 위한 윈도우 확장 요소로 이용된다.
* 플래그(flag) 필드
  * CWR,ECE : 명시적 혼합표시에서 사용된다.
  * ACK : 확인응답 필드에 있는 값이 유용함을 가리키는데 사용된다.
  * PSH : 수신자가 데이터를 상위 계층에 즉시 전달해야 한다는 것을 가리킨다.
  * RST,SYN,FIN : 연결 설정과 해제에 사용된다.
  * URG : 이 세그먼트에서 송신 측 상위 계층 개체(entity)가 "긴급"으로 표시하는 데이터임을 가리킨다.
* 긴급 데이터 포인터 : URG에서의 긴급 데이터의 마지막 바이트의 위치를 가리킨다.
* 인터넷 체크섬
* 데이터

## 신뢰적인 데이터 전달
* TCP는 IP의 비신뢰적인 서비스 위에다가 rdt 서비스를 만든다.
  * 파이프라인 세그먼트
    * 처리량을 증가시키기 위함
  * 누적 ack
  * 단일 재전송 타이머
    * 하나의 connection에 대해서 하나의 타이머를 사용한다.

* 다음 이벤트를 통해 재전송
  * 타임아웃 이벤트
  * 중복 ack

가장 간단한 시나리오에서 TCP의 송신자와 수신자의 동작을 살펴본다.  

## TCP 트랜스포트 계층 송신측 이벤트
* 앱으로부터 데이터를 받는 경우

  * 순서번호를 매겨서 세그먼트를 만든다.

    * 즉 헤더에 sequence번호를 붙여서 세그먼트를 만든다.

  * 순서번호는 세그먼트에서 첫 번째 데이터 바이트의 바이트 스트림 번호이다.

  * 타이머가 실행되지 않는 상황이라면 타이머를 실행시킨다.
    * 전송한 세그먼트중 ack을 못받은 가장 오래된 세그먼트 기준으로 세팅된다.

    * 이미 타이머가 돌고 있다면 이미 전송후 못받고 있는 세그먼트가 존재한다는 의미가 된다. 따라서 타이머를 세팅하지 않아도 된다.
    * 
* 상대방으로부터 ack을 받는 경우
  * ack이 ack되지 않은 세그먼트에 대해서 들어온 경우
    * ack으로 알려진 내용을 업데이트한다.
    * 여전히 ack되지 않은 세그먼트가 있는 경우 타이머 시작
* 타임아웃
  * 타임아웃이 발생된 세그먼트를 재전송 해줘야한다.
  * 재전송 후에는 타이머를 다시 시작해줘야한다.

## TCP 흐름제어(flow control)
수신측은 송신측에서 너무 빠르게 전송하여 수신측의 버퍼가 가득 차 넘치는 상황에 대하여 컨트롤 한다.  

<img width="500" alt="image" src="https://user-images.githubusercontent.com/87526189/187061040-bbba53f7-b430-4b54-9dfd-35eaa43ed9e5.png">  

* 수신자는 송신측에게 보낼 세그먼트의 TCP 헤더에 "rwnd" 값을 포함하여 버퍼공간이 비어있다는 것을 알린다.
  * RcvBuffer의 크기는 소켓 옵션을 통해 설정된다.(일반적으로 기본값은 4096byte)
  
  * 많은 운영체제가 RcvBuffer를 자동으로 조절한다.
* 송신측은 수신측의 rwnd값으로 부터 실행 중 ack받지 않은 데이터의 양을 제한한다.

* 수신 버퍼가 오버플로되지 않도록 보장한다.  

## TCP 연결 관리
* 데이터를 교환하기 전, 송신자/수신자 는 핸드셰이킹을 한다.
  * 3way 핸드셰이킹을 한다.  
  <img width=500 src="https://user-images.githubusercontent.com/87526189/187138466-cc0fde4b-1809-4352-9b19-a4b834909737.png">  

# 혼잡제어(congestion control)의 원리
## 혼잡(congestion) 이란?
* 송신측에서 많은 데이터를 너무 빨리 보내서 네트워크가 처리할 수 없는 상황을 말한다.
* 흐름제어(flow control)과 다른 개념이다.
* 혼잡이 발생했을 경우 나타나는 징조
  * 패킷 로스가 발생(라우터에서 오버플로우가 발생함)
  * 긴 지연(라우터 버퍼에서 큐잉 딜레이발생)

## 혼잡제어에 대한 접근법
1. 종단간의 혼잡제어(end-end congestion control)

   1. end-system의 손실, 지연을 통해서 혼잡을 예측한다.

   2. TCP가 채택하고 있는 방식이다.

2. 네트워크 지원 혼잡제어(network-assisted congestion control)

   1. 라우터에 혼잡이 발생하면 end-system에 피드백을 제공한다

      1. 혼잡을 단일 비트로 피드백 제공하는 방식(SNA, DECbit, TCP/IP ECN, ATM)
      2. 명시적으로 전송 속도를 송신측으로 피드백을 제공하는 방식

# TCP 혼잡제어(congestion control)
접근방법 : 전송자가 전송속도(윈도우 크기)를 증가시켜 손실이 발생할 때까지 사용가능한 대역폭을 조사한다.  
<img width=600 src="https://user-images.githubusercontent.com/87526189/187190737-2d30ad7e-2aa9-4b20-a1ed-0ba9494255c5.png">  

* 덧셈식 증가 : 손실이 감지될 때까지 매 RTT(round trip time)마다 cwnd(congestion window)를 1MSS(maximum segment size)씩 늘려나간다.
* 곱셈 감소 : 손실발생 후 cwnd를 반으로 줄인다.

## TCP 슬로우 스타트(Slow Start)
<img width=400 src="https://user-images.githubusercontent.com/87526189/187214818-35f080f8-8289-4555-81f0-bdea0c83d2ed.png">  

* 연결됐을 때 첫 손실이 발생하기 전까지 속도를 기하급수적으로 증가시킨다.
  * 초기 cwnd = 1 MSS
  * 매 RTT마다 두배로 증가
  * 수신한 모든 ACK에 대해서 cwnd 증가시키는 방식으로 수행됨

* 요약하면 초기 속도는 느리지만 기하급수적으로 빨라진다.

## TCP 혼잡회피(Congestion Avoidance)
* ssthresh
  * cwnd의 임계값을 사용하여 증가 속도를 늦춘다.
  * 연결이 시작되면, ssthresh는 OS에 의해 결정된 초기값으로 설정된다.
  * 만약 손실이 발생한다면 ssthresh=cwnd / 2로 설정된다.
* cwnd가 ssthresh에 도달하면 혼잡회피가 시작된다.
  * 매 RTT에서 cwnd를 1씩 증가시킨다.
  * 수신된 모든 ACK에 대하여 (MSS/cwnd)씩 cwnd를 증가시키므로써 수행된다.

* 요약하면
  * 만약 (cwnd<ssthresh) 라면 느린 시작 단계(매 RTT마다 두배의 cwnd)이고
  * 아니라면 혼잡회피 단계(매 RTT마다 1씩 cwnd증가)이다.

## TCP: 손실 감지 및 반응
* 시간초과로 손실이 발생한 경우
  * cwnd는 1 MSS로 설정된다.
  * 그런 다음 윈도우가 인계점까지 기하급수적(슬로우 스타트처럼)으로 증가하다가 선형적으로 증가한다.
* 3번의 중복 ACK에 의해 손실이 발생한 경우:TCP RENO
  * 중복 ACK는 일부 세그먼트를 전송할 수 있는 네트워크라는 것을 나타낸다.
  * cwnd는 윈도우가 반으로 감소한 후 선형적으로 증가한다.
* TCP Tahoe는 항상 cwnd를 1로 설정한다.(타임아웃 또는 3번의 중복 ACk)

## TCP: 슬로우 스타트에서 혼잡회피로 전환
![image](https://user-images.githubusercontent.com/87526189/187230802-a47620e1-2117-4469-991a-03f8229be631.png)  

* Q. 기하급수적으로 증가하다가 언제 선형적으로 변경되어야 하는가?  
-> A : cwnd가 타임아웃이 발생하기 전 값의 1/2이 되었을 때

<br/>

---
# 5주차

# 네트워크 계층 개요
*  트랜스포트 세그먼트를 송신 호스트에서 수신 호스트로 전송하려는 목적을 가지고 있다.

*  송신측에서 세그먼트를 데이터그램으로 캡슐화하여 인접한 라우터 R1에 데이터그램을 보낸다.
*  네트워크 계층 프로토콜은 모든 호스트와 라우터에 탑제되어 있다.
*  코어의 라우터는 IP 데이터그램이 들어오면 헤더를 보고 어디로 라우터를 해줘야하는지 결정해주게 된다. 

## 네트워크 계층 라우팅과 포워딩
* 라우팅(routing) : 목적지별로 어떻게 경로를 설정하여 가는지 결정하는 것

* 포워딩(forwarding) : 데이터그램이 라우터의 input 포트로 들어왔을 때 그것을 목적지로 보내기 위해서 어떤 output 포트로 뽑아야하는지에 대해 결정하여 내보내는 것
  * 라우팅에서 계산해놓은 경로정보를 활용한다.

### 라우팅과 포워딩 사이의 상호작용
<img width="775" alt="image" src="https://user-images.githubusercontent.com/87526189/188087133-572c0c41-68a3-4a83-a1d5-28c8ca7130d4.png">  

1. 라우터는 라우팅 알고리즘을 통해서 네트워크의 모든 목적지에 대해서 경로를 계산해낸다. 

3. 계산한 결과를 테이블에다 저장을 하는데 이 테이블을 "로컬 포워딩 테이블"이라고 한다.
4. 헤더값에 적혀있는 목적지 주소에 대해서 어떤 출력 링크로 연결해줘야될지 표시를 해둔다.
5. 도착하는 데이터그램 패킷의 헤더값에 적혀있는 목적지 주소를 보고 목적지 주소를 포워딩 테이블에서 찾아서 출력 링크를 결정하여 출력해주는 작업을 포워딩이라 한다.

## 네트워크 서비스 모델
* 개별 데이터그램을 위한 서비스

  * 네트워크의 서비스로써 각 데이터그램의 전송을 보장한다.

  * 특정(40msec) 시간내에 전송하는 것을 보장한다.

* 데이터그램의 흐름을 위한 서비스

  * 순차적인 데이터그램 전송을 보장

  * 흐름에 대한 최소 대역폭을 보장
  * 흐름에 속하는 패킷들 간에 특정 도착시간 간격이내 보장

# 라우터 아키텍처
![image](https://user-images.githubusercontent.com/87526189/188300805-245197b3-3708-443b-b653-98b8d50c3a2c.png)  
## 1. 입력포트
![image](https://user-images.githubusercontent.com/87526189/188300895-20c00fda-9ff6-4ef6-bf1e-97cf4b51dcf8.png)  
1. 라인 종단

   1. 비트 계층의 값을 접수를 한다.

2. 데이터 링크 처리
   1. 라인 종단에서 모든 비트를 모아 프레임을 구성하게되면 이 프레임이 하나 둘 잘 건너왔는지를 체크하는 링크 계층 프로토콜을 수행하게 된다.
3. 검색 포워딩 큐잉
   1. 프레임을 목적지로 보내기 위해 다음 홉으로 내보낼 출력 포트 번호를 포워딩 테이블에서 찾게된다.

**입력포트의 목적** : 데이터가 미디어를 통해서 들어오는 속도와 동일한 속도로 수행되는 것이 목표이다.

**큐잉** : 스위칭 구조로 내보내기까지 대기할 수 있도록 하기 위해 버퍼를 두게 된다.
### 입력 포트 큐잉
![image](https://user-images.githubusercontent.com/87526189/188302253-fa72f394-41ef-4494-904c-3a271d604b84.png)  
* 스위치 구조보다 입력포트가 느리다면 입력포트에서 큐잉 딜레이가 발생하게 된다. 

  * 심한 경우에는 버퍼의 오버플로우에 의한 손실까지 발생할 수 있다.

* Head-of-the-Line(HOL) blocking : 스위치 구조는 동시에 2개 이상의 데이터그램을 동일한 출력포트로 전달하지 못한다. 따라서 하나의 입력포트만 출력포트로 데이터그램을 전달할 수 있게 되고 나머지는 차단된다.

## 2. 스위치구조
* 입력버퍼에서 적절한 출력 버퍼로 패킷을 전송한다.
* 스위칭 속도 : 패킷이 입력에서 출력으로 전송될 수 있는 속도

  * 입력/출력 라인 속도의 배수로 측정되는 경우가 많다.

  * 입력라인이 N개라면 N*라인속도가 된다.
* 스위칭구조의 3가지 종류
  1. 메모리
  2. 버스
  3. 크로스바
### 메모리
![image](https://user-images.githubusercontent.com/87526189/188303385-d632789c-44eb-46cf-91b7-3eb659e9d95c.png)  
* 스위칭을 위한 별도의 전담 프로세서 없이 cpu의 직접적인 제어 하에 이루어진다.
* 입력포트로부터 시스템의 메모리에 패킷이 복사가 되고 다시 메모리로부터 출력포트로 복사이 이루어진다.
* 메모리에 접근하기 위한 대역폭에 의해서 스위치구조의 속도가 결정이 되고 시스템버스를 2번 타야하는 제약이 발생한다.

  *  입력포트에서 메모리로 / 메모리에서 출력포트로 전달되기 위해서 총 2번 시스템버스를 타야지만 입력포트에서 출력포트로 이동을 할 수 있다.
### 버스
![image](https://user-images.githubusercontent.com/87526189/188303629-4cf7eca2-cba6-4b48-b5e0-c75be125807a.png)  
입력포트와 출력포트를 직접연결하는 독점적인 버스를 스위치구조로 사용되는 구조가 제안되었다.  
* 공유버스를 통해 입력포트 메모리에서 출력포트 메모리로 데이터그램을 보낸다.

* bus contention : 한 번에 단 하나의 패킷만이 버스에 접근할 수 있기 때문에 여러 입력포트에서 2개 이상의 패킷이 유입되는 경우에는 서로 버스를 차지하려는 bus contention이 발생하고 이러한 contention을 제어할 수 있는 메커니즘이 필요하다. 
  * 버스 대역폭에 의해 스위칭 속도가 결정된다.

### 크로스바
![image](https://user-images.githubusercontent.com/87526189/188304067-b1560ed5-0fdf-445b-8c4a-7944b93ed336.png)  
입력포트와 출력포트를 하나의 버스로 연결하므로써 만들어진다.
* 버스의 제한적인 대역폭을 극복하기 위해서 사용된다.

* 멀티프로세서 환경에서 프로세서들 간에 연결을 위해서 개발된 것이다.(banyan네트워크, 크로스바, 기타 상호 연결망)
* 발달된 디자인 : 고정길이의 셀로 분할하여 스위칭한다.

## 3. 출력포트
![image](https://user-images.githubusercontent.com/87526189/188304695-3954acc1-75c3-4821-902d-3c6909fad213.png)  
* 출력포트에서의 전송속도보다 빠르게 스위치구조에 데이터그램이 도착할 때 버퍼링이 필요하다.
* 전송하기 위해서 대기 중인 데이터그램 중에서 어떤것을 전송 미디엄으로 뽑아내야할지를 결정하는 스케줄링 규칙이 적용될 수 있다.

### 출력포트 큐잉
* 출력 라인 속도보다 스위치를 통한 도착 속도가 빠를 때 버퍼링된다.
* 출력포트 버퍼의 오버플로우 때문에 큐잉딜레이와 손실이 발생한다.

# 인터넷 프로토콜(IP):IPv4, 주소지정,IPv6
네트워크 계층에는 라우팅 프로토콜, IP프로토콜, ICMP 프로토콜 총 3개의 프로토콜이 존재한다.
<img width="559" alt="image" src="https://user-images.githubusercontent.com/87526189/188311299-7312ce58-c134-4730-95d9-9deedfda8ac4.png">  

* IP 프로토콜  
  -> 데이터 전송과 관련된 사항에대해 정의하고 있다.
  * 주소 지정 방식 정의
  * 데이터그램 포맷 정의
  * 패킷 핸들링 방식 정의

* 라우팅 프로토콜
  * 목적지에 대한 경로 개선에 사용되는 정보들을 네트워크 모드들 간에 주고받고 경로를 선택하는 등 관련된 사항에 대해 정의하고 있다.
* ICMP 프로토콜
## IPv4 데이터그램 형식
![image](https://user-images.githubusercontent.com/87526189/188312263-217b7b94-7f9b-4a75-af16-c2255856b5af.png)  

* 버전

  * IP 프로토콜의 버전 번호

* 헤더길이

  * 수신측에서 IP 데이터그램을 받았을 때 어디까지가 헤더인지 파악할 수 있도록 헤더의 길이를 몇 바이트인지 표기함

* 서비스타입

  * 데이터그램에 실린 데이터가 필요로하는 서비스 타입이 무엇인지 명시
  * 실제로 사용되지는 않음

* 데이터그램 길이
  * 데이터그램 전체의 길이
* 16비트 인식자
* 플래그
* 13비트 단편화 오프셋
* Time-to-live

  * 앞으로 이 데이터그램이 거칠 수 있는 남아있는 홉들의 최대개수를 명시
  * 각 라우터를 거칠 때 마다 하나씩 감소

* 상위 계층 프로토콜

  * 상위 계층에서 사용하는 프로토콜의 종류(ex TCP/ UDP)

* 헤더 체크섬
* 32비트 출발지 IP주소
* 32비트 목적지 IP주소
* 옵션
  * 가변길이이다
  * IP헤더를 확장하는 기능이다.
  * 타임스탬프, 사용된 경로 기록, 방문할 라우터 목록 지정 등
* 데이터

## IPv4 데이터그램 단편화
![image](https://user-images.githubusercontent.com/87526189/188315539-eef3fe2e-66b9-4d14-b399-03f51f185417.png)  

* 네트워크 각 링크는 물리적 특정으로 인해 MTU(max transfer size)가 정해진다.
  * 링크계층에서 생성하는 프레임의 가능한 최대크기를 말한다. 
* 하나의 IP 데이터그램을 여러개의 작은 IP 데이터그램으로 나눠서 단편화 시킨다.
  * 하나의 데이터그램이 여러개의 데이터그램으로 쪼개진다.
  * 마지막 목적지에서 재조립된다.
  * IP헤더 비트는 독립적으로 사용되며 정렬하는 데 사용된다.

## IPv4 주소체계
* IP 주소 : 호스트와 라우터 인터페이스의 32비트 식별자이다.
* 인터페이스 : 호스트/라우터와 물리적 링크 사이에서 연결해주는 역할을 한다.
  * 라우터들은 일반적으로 멀티 인터페이스를 가진다.
  * 호스트는 하나 혹은 두개의 인터페이스를 가진다. (이더넷, 무선 802.11)
* IP주소는 각각의 인터페이스들과 연결된다.

### 서브넷(Subnets)
* 서브넷 파트 : 상위 비트로 구분
* 호스트 파트 : 하위 비트로 구분

서브넷이란?
![image](https://user-images.githubusercontent.com/87526189/188317696-7cafbe90-5290-49d4-9ac3-ca9ff9be626a.png)  

* IP주소의 같은 서브넷 파트를 가지는 장치 인터페이스들이다.
* 각각 다른 라우터를 개입시키지 않고도 물리적으로 서로 도달할 수 있다.

어떠한 인터페이스들이 동일한 서브넷을 가지고 있는지 알고 싶다면 인터페이스를 호스트와 라우터에서 분리하여 만들어진 네트워크 섬을 만들면 된다.  

이때 만들어진 네트워크 섬을 서브넷(subnet)이라 한다.

![image](https://user-images.githubusercontent.com/87526189/188317897-e831813e-094d-4378-9652-e67bd932243b.png)  
 IP 주소체계는 이 서브넷에 223.1.1.0/24라는 주소를 할당하는데, 여기서 /24(“슬래시-24”)는 서브넷 마스크(subnet mask)라 부르는데, 32비트 주소의 왼쪽 24비트가 서브넷 주소라는 것을 가리킨다.

### CIDR
* CIDR : Classless InterDomain Routing
  * 서브넷 주소체계 표기를 일반화
  * 임의 길이의 주소의 서브넷 부분.
  * 32비트 IP주소를 두 부분으로 나누고, 이것을 다시 점으로 된 십진수 형태의 a.b.c.d/x를 가진다.
  * x는 서브넷 부분에 있는 #비트이다.

## 네트워크 주소 변환(NAT)
<img width="861" alt="image" src="https://user-images.githubusercontent.com/87526189/188450137-6f9c7b8c-5a77-48b7-9b0d-320d63aeba3c.png">  

* 로컬 네트워크를 떠나는 모든 데이터그램은 같은 출발 NAT IP 주소 138.76.29.7을 가지고 서로 다른 출발 포트번호를 가진다.

* 로컬 네트워크속 출발/도착 데이터그램은 10.0.0/24 주소를 가진다.

* 모든 장치에 대해 하나의 IP 주소만 제공
* 외부 네트워크에 알리지 않고 로컬 네트워크에서 장치의 주소를 변경
* 로컬 네트워크에서 장치의 주소를 변경하지 않고 ISP를 변경할 수 있음
* 로컬 네트워크 내부의 장치는 명시적으로 주소를 부여할 수 없고 외부에 의해서 볼 수 있다.(보안)







<br/>

# Reference
네트워크 강의  
http://www.kocw.net/home/cview.do?cid=e44bdd9b3a3f9bb5  

교재  
Computer Networking A Top Down Approach, 7th, converted / james F. Keith W.Ross  
컴퓨터 네트워크(하향식접근) / james F. Keith W.Ross
